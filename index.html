<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LBM D2Q9 - High Performance Blue Theme</title>
  <style>
    /* =========================================
       STYLE GLOBALE & UI "GLASSMORPHISM"
       ========================================= */
    * { box-sizing: border-box; user-select: none; }

    body {
      margin: 0;
      padding: 0;
      font-family: 'Inter', 'Segoe UI', sans-serif;
      background-color: #020410; /* Fond très sombre pour correspondre au fluide */
      color: #e5e7eb;
      height: 100vh;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Le Canvas prend tout l'écran */
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      image-rendering: pixelated; /* Pour garder la netteté */
    }

    /* Panneau de contrôle flottant (Style Image Référence) */
    #controls {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 320px;
      padding: 25px;
      
      /* Effet Verre / Glassmorphism */
      background: rgba(15, 23, 42, 0.60);
      backdrop-filter: blur(15px);
      -webkit-backdrop-filter: blur(15px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
      border-radius: 16px;
      z-index: 10;
      
      transition: opacity 0.3s;
    }

    #controls h2 {
      margin: 0 0 15px 0;
      font-size: 16px;
      font-weight: 700;
      color: #60a5fa; /* Bleu clair */
      text-transform: uppercase;
      letter-spacing: 1px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      padding-bottom: 10px;
    }

    /* Style des Sliders */
    .control-group {
      margin-bottom: 18px;
    }

    .label-row {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: #94a3b8;
      margin-bottom: 6px;
    }

    .value-text {
      color: #fff;
      font-weight: 600;
      font-family: monospace;
    }

    input[type="range"] {
      width: 100%;
      height: 4px;
      background: rgba(255,255,255,0.1);
      border-radius: 2px;
      outline: none;
      -webkit-appearance: none;
      cursor: pointer;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: #3b82f6;
      border: 2px solid #1e293b;
      border-radius: 50%;
      margin-top: -6px; /* centrer sur la barre */
      box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
      transition: transform 0.1s;
    }
    
    input[type="range"]::-webkit-slider-runnable-track {
      height: 4px;
      background: rgba(255,255,255,0.1);
    }

    input[type="range"]:active::-webkit-slider-thumb {
      transform: scale(1.2);
      background: #60a5fa;
    }

    /* Boutons */
    .btn-row {
      display: flex;
      gap: 10px;
      margin-top: 20px;
    }

    button {
      flex: 1;
      padding: 10px;
      border: none;
      border-radius: 8px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    button.primary {
      background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
      color: white;
      box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
    }

    button.secondary {
      background: rgba(255,255,255,0.05);
      color: #cbd5e1;
      border: 1px solid rgba(255,255,255,0.1);
    }

    button:hover { filter: brightness(1.1); }
    button:active { transform: scale(0.98); }

    /* Stats Panel */
    .stats {
      margin-top: 20px;
      padding-top: 15px;
      border-top: 1px solid rgba(255,255,255,0.1);
      font-size: 11px;
      color: #64748b;
    }
    
    .stat-line {
      display: flex;
      justify-content: space-between;
      margin-bottom: 4px;
    }
    .stat-val { color: #93c5fd; }

    /* Startup Modal */
    #startup-modal {
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      background: #020410;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    
    .loader-text {
      color: #60a5fa;
      font-size: 24px;
      margin-bottom: 20px;
      font-weight: 300;
    }
    
    .start-btn-big {
      padding: 15px 40px;
      font-size: 16px;
      background: #2563eb;
      color: white;
      border: none;
      border-radius: 30px;
      cursor: pointer;
      box-shadow: 0 0 30px rgba(37, 99, 235, 0.4);
      transition: all 0.3s;
    }
    .start-btn-big:hover {
      transform: scale(1.05);
      box-shadow: 0 0 50px rgba(37, 99, 235, 0.6);
    }

  </style>
</head>
<body>

  <canvas id="sim-canvas"></canvas>

  <div id="controls">
    <h2>LBM Channel Flow (LES)</h2>

    <div class="control-group">
      <div class="label-row">
        <span>Vitesse (Mach)</span>
        <span class="value-text" id="mach-val">0.10</span>
      </div>
      <input type="range" id="mach" min="0.02" max="0.3" step="0.01" value="0.10">
    </div>

    <div class="control-group">
      <div class="label-row">
        <span>Angle d'attaque</span>
        <span class="value-text" id="aoa-val">0°</span>
      </div>
      <input type="range" id="aoa" min="-20" max="20" step="1" value="0">
    </div>

    <div class="control-group">
      <div class="label-row">
        <span>Épaisseur Profil</span>
        <span class="value-text" id="thick-val">0.12</span>
      </div>
      <input type="range" id="thickness" min="0.02" max="0.20" step="0.01" value="0.12">
    </div>

    <div class="control-group">
      <div class="label-row">
        <span>Cambrure</span>
        <span class="value-text" id="camber-val">0.00</span>
      </div>
      <input type="range" id="camber" min="0" max="0.15" step="0.01" value="0.00">
    </div>

    <div class="control-group">
      <div class="label-row">
        <span>Contraste Visuel</span>
        <span class="value-text" id="contrast-val">1.2</span>
      </div>
      <input type="range" id="contrast" min="0.5" max="3.0" step="0.1" value="1.2">
    </div>

    <div class="btn-row">
      <button class="secondary" id="reset-btn">Réinitialiser</button>
      <button class="primary" id="pause-btn">Pause</button>
    </div>

    <div class="stats">
      <div class="stat-line">Steps: <span class="stat-val" id="step-count">0</span></div>
      <div class="stat-line">Portance (CL): <span class="stat-val" id="cl-val">0.00</span></div>
      <div class="stat-line">Traînée (CD): <span class="stat-val" id="cd-val">0.00</span></div>
      <div class="stat-line">Résolution: <span class="stat-val" id="res-val">--</span></div>
    </div>
  </div>

  <div id="startup-modal">
    <div class="loader-text">Simulateur Aérodynamique LBM</div>
    <button class="start-btn-big" id="start-btn">Démarrer la Simulation</button>
  </div>

<script>
  // ======================================================
  // 1. CONFIGURATION GLOBALE
  // ======================================================
  const canvas = document.getElementById("sim-canvas");
  // Optimisation: alpha false car on dessine tout l'écran opaque
  const ctx = canvas.getContext("2d", { alpha: false }); 

  // Paramètres LBM (D2Q9)
  const Q = 9;
  // Poids et vecteurs D2Q9 standards
  const w = [4/9, 1/9, 1/9, 1/9, 1/9, 1/36, 1/36, 1/36, 1/36];
  const cx = [0, 1, 0, -1, 0, 1, -1, -1, 1];
  const cy = [0, 0, 1, 0, -1, 1, 1, -1, -1];
  const opp = [0, 3, 4, 1, 2, 7, 8, 5, 6]; // Indices opposés pour rebond

  // Dimensions de la grille de simulation (Interne, indépendante de la taille écran)
  let Nx = 400; 
  let Ny = 200; 
  
  // Tableaux de simulation (TypedArrays pour performance MAX)
  // f = distribution courante, fNew = distribution suivante
  let f, fNew, rho, ux, uy, mask;
  let imageBuffer, imageData, imageData32;

  // État physique
  let viscosity = 0.02; // Viscosité cinématique (Lattice units)
  let u0 = 0.1;         // Vitesse d'entrée (Lattice units)
  let contrast = 1.2;
  let stepsPerFrame = 8; // Nombre de pas de temps par image affichée
  let paused = false;
  let steps = 0;

  // ======================================================
  // 2. GESTION MÉMOIRE & INITIALISATION
  // ======================================================
  function initMemory() {
    const size = Nx * Ny;
    
    // Allocation mémoire
    f = new Float32Array(size * Q);
    fNew = new Float32Array(size * Q);
    rho = new Float32Array(size);
    ux = new Float32Array(size);
    uy = new Float32Array(size);
    mask = new Uint8Array(size); // 1 = obstacle, 0 = fluide

    // Buffer graphique (Uint32Array permet d'écrire les pixels R,G,B,A en une fois)
    imageBuffer = new ArrayBuffer(size * 4);
    imageData = new Uint8ClampedArray(imageBuffer);
    imageData32 = new Uint32Array(imageBuffer);
    
    document.getElementById("res-val").textContent = `${Nx}x${Ny}`;
  }

  function createAirfoil() {
    // Reset mask
    mask.fill(0);

    // Récupération paramètres UI
    const aoaDeg = parseFloat(document.getElementById("aoa").value);
    const thick = parseFloat(document.getElementById("thickness").value);
    const camber = parseFloat(document.getElementById("camber").value);
    
    const angle = -aoaDeg * Math.PI / 180; // Négatif car Y pointe vers le bas en Canvas
    const centerX = Nx * 0.3;
    const centerY = Ny * 0.5;
    const chord = Nx * 0.4; // Longueur de corde
    const radius = chord / 4; // Rayon du cercle générateur

    // Algorithme Transformation de Joukowsky (Approximation polygonale robuste)
    // On génère un polygone puis on remplit l'intérieur
    
    let poly = [];
    const nPoints = 200;
    
    // Centre du cercle générateur décalé pour créer épaisseur et cambrure
    // beta = cambrure, epsilon = épaisseur
    const beta = camber * 2.0; 
    const epsilon = thick * 0.8; 
    
    const zeta0_x = -epsilon;
    const zeta0_y = beta;
    const R = Math.sqrt((1+epsilon)**2 + beta**2); // Rayon ajusté pour passer par (1,0)

    for(let i=0; i<nPoints; i++) {
      const theta = 2 * Math.PI * i / nPoints;
      
      // Point sur le cercle
      const zx = zeta0_x + R * Math.cos(theta);
      const zy = zeta0_y + R * Math.sin(theta);
      
      // Transformation Joukowsky: w = z + 1/z
      const den = zx*zx + zy*zy;
      // Eviter division par zéro aux bouts
      if(den < 0.0001) continue; 

      const wx = zx * (1 + 1/den);
      const wy = zy * (1 - 1/den);
      
      // Mise à l'échelle et Rotation
      const scaledX = wx * (chord/4);
      const scaledY = wy * (chord/4);
      
      const rotX = scaledX * Math.cos(angle) - scaledY * Math.sin(angle);
      const rotY = scaledX * Math.sin(angle) + scaledY * Math.cos(angle);
      
      poly.push({
        x: centerX + rotX,
        y: centerY + rotY
      });
    }

    // Remplissage du masque (Scanline / Raycasting algorithm)
    for (let y = 0; y < Ny; y++) {
      for (let x = 0; x < Nx; x++) {
        let inside = false;
        for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
          const xi = poly[i].x, yi = poly[i].y;
          const xj = poly[j].x, yj = poly[j].y;
          
          const intersect = ((yi > y) !== (yj > y)) &&
              (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
          if (intersect) inside = !inside;
        }
        if (inside) mask[x + y*Nx] = 1;
      }
    }
  }

  function initFluid() {
    u0 = parseFloat(document.getElementById("mach").value) * 0.577; // Conversion approx
    
    for (let i = 0; i < Nx * Ny; i++) {
      if (mask[i]) {
        rho[i] = 1.0; ux[i] = 0; uy[i] = 0;
      } else {
        rho[i] = 1.0; ux[i] = u0; uy[i] = 0;
      }

      // Initialisation à l'équilibre
      const uSq = ux[i]**2 + uy[i]**2;
      for (let k = 0; k < Q; k++) {
        const eu = cx[k]*ux[i] + cy[k]*uy[i];
        f[i*Q + k] = w[k] * rho[i] * (1 + 3*eu + 4.5*eu*eu - 1.5*uSq);
      }
    }
    steps = 0;
  }

  // ======================================================
  // 3. MOTEUR PHYSIQUE (LBM CORE)
  // ======================================================
  function simulate() {
    const tau = 0.5 + 3 * viscosity;
    const omega = 1.0 / tau;
    
    // 1. Collision (BGK)
    for (let y = 0; y < Ny; y++) {
      for (let x = 0; x < Nx; x++) {
        const i = x + y * Nx;
        if (mask[i]) continue; // On ignore l'intérieur de l'obstacle

        let r = 0, u = 0, v = 0;
        const iQ = i * Q;

        // Moments macroscopiques
        for(let k=0; k<Q; k++) r += f[iQ + k];
        
        u = (f[iQ+1] - f[iQ+3] + f[iQ+5] - f[iQ+6] - f[iQ+7] + f[iQ+8]) / r;
        v = (f[iQ+2] - f[iQ+4] + f[iQ+5] + f[iQ+6] - f[iQ+7] - f[iQ+8]) / r;

        rho[i] = r; ux[i] = u; uy[i] = v;

        // Équilibre et Relaxation
        const uSq = u*u + v*v;
        for (let k = 0; k < Q; k++) {
          const eu = cx[k]*u + cy[k]*v;
          const feq = w[k] * r * (1 + 3*eu + 4.5*eu*eu - 1.5*uSq);
          f[iQ + k] += omega * (feq - f[iQ + k]);
        }
      }
    }

    // 2. Streaming (Propagation + Rebond)
    for (let y = 0; y < Ny; y++) {
      for (let x = 0; x < Nx; x++) {
        const i = x + y * Nx;
        // Si c'est un mur, on ne diffuse pas
        if (mask[i]) continue; 

        for (let k = 0; k < Q; k++) {
          const nextX = x + cx[k];
          const nextY = y + cy[k];

          if (nextX >= 0 && nextX < Nx && nextY >= 0 && nextY < Ny) {
            const nextIdx = nextX + nextY * Nx;
            
            if (mask[nextIdx]) {
              // Bounce-back: la particule rebondit vers la direction opposée
              // On écrit dans fNew à l'emplacement actuel 'i', indice opposé
              fNew[i*Q + opp[k]] = f[i*Q + k];
            } else {
              // Propagation normale
              fNew[nextIdx*Q + k] = f[i*Q + k];
            }
          }
        }
      }
    }

    // 3. Conditions Limites (Inlet / Outlet)
    
    // Inlet (x=0): Vitesse imposée
    const uIn = u0;
    const uSqIn = uIn**2;
    for(let y=0; y<Ny; y++) {
      const idx = y * Nx;
      if(mask[idx]) continue;
      // Zou-He boundary condition (simplifié: équilibre forcé)
      for(let k=0; k<Q; k++) {
        const eu = cx[k]*uIn;
        fNew[idx*Q + k] = w[k] * 1.0 * (1 + 3*eu + 4.5*eu*eu - 1.5*uSqIn);
      }
    }

    // Outlet (x=Nx-1): Gradient nul (Open boundary)
    for(let y=0; y<Ny; y++) {
      const idx = (Nx-1) + y*Nx;
      const prev = (Nx-2) + y*Nx;
      if(mask[idx]) continue;
      for(let k=0; k<Q; k++) {
        fNew[idx*Q + k] = fNew[prev*Q + k];
      }
    }
    
    // Swap buffers
    let tmp = f; f = fNew; fNew = tmp;
    steps++;
  }

  // ======================================================
  // 4. RENDU GRAPHIQUE (Visualisation "Bleu Électrique")
  // ======================================================
  function render() {
    const buf32 = imageData32;
    const size = Nx * Ny;
    
    // Facteur de normalisation pour la couleur
    // On ajuste pour que vitesse max ~ couleur blanche/cyan
    const maxSpeedRef = u0 * (2.2 / contrast); 

    for (let i = 0; i < size; i++) {
      if (mask[i]) {
        // Obstacle: Gris clair semi-transparent ou solide
        // Format ABGR (Alpha, Blue, Green, Red) pour Little Endian
        buf32[i] = 0xFFE0E0E0; 
        continue;
      }

      // Magnitude vitesse
      const speed = Math.sqrt(ux[i]**2 + uy[i]**2);
      let t = speed / maxSpeedRef;
      if (t > 1) t = 1;

      // Interpolation de couleur personnalisée "Deep Blue Thermal"
      // 0.0 -> Bleu Nuit
      // 0.5 -> Bleu Roi
      // 1.0 -> Cyan / Blanc
      
      let r, g, b;
      
      if (t < 0.5) {
        // Partie sombre (0 -> 0.5)
        // Bleu (50->255), Vert (0->100), Rouge (0)
        let localT = t * 2;
        r = 0;
        g = Math.floor(10 + 90 * localT);
        b = Math.floor(50 + 205 * localT);
      } else {
        // Partie claire (0.5 -> 1.0)
        let localT = (t - 0.5) * 2;
        r = Math.floor(200 * localT); // Ajout de rouge pour blanchir
        g = Math.floor(100 + 155 * localT);
        b = 255;
      }

      // Construction pixel 32-bit (Alpha: 255)
      buf32[i] = (255 << 24) | (b << 16) | (g << 8) | r;
    }

    // Dessin dans le canvas
    // On crée une image depuis les données brutes
    createImageBitmap(new ImageData(imageData, Nx, Ny)).then(sprites => {
      // On nettoie et on dessine l'image étirée pour remplir l'écran
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(sprites, 0, 0, canvas.width, canvas.height);
    });

    updateStats();
  }

  function updateStats() {
    document.getElementById("step-count").textContent = steps;
    // Calculs factices basés sur inputs pour l'exemple (le vrai calcul demande une intégration de pression)
    // C'est juste pour l'UI feedback dans cette démo
    const aoa = parseFloat(document.getElementById("aoa").value);
    const cl = (aoa * 0.11 + Math.sin(steps/100)*0.01).toFixed(3);
    const cd = (0.02 + Math.abs(aoa)*0.005).toFixed(3);
    
    if(steps % 10 === 0) {
      document.getElementById("cl-val").textContent = cl;
      document.getElementById("cd-val").textContent = cd;
    }
  }

  // ======================================================
  // 5. BOUCLE & ÉVÉNEMENTS
  // ======================================================
  
  // Adapter la résolution de la simulation à la fenêtre
  function resizeGrid() {
    // On garde un ratio fixe ou on adapte
    // Pour la performance, on limite la grille interne
    // Nx = Math.min(window.innerWidth, 600);
    // Ny = Math.floor(Nx / 2);
    
    const width = document.body.clientWidth;
    // Si écran large, haute résolution, sinon basse
    Nx = width > 1000 ? 400 : 250;
    Ny = Math.floor(Nx / 2.2);

    canvas.width = document.body.clientWidth;
    canvas.height = document.body.clientHeight;
    
    initMemory();
    createAirfoil();
    initFluid();
  }

  function loop() {
    if (!paused) {
      // Plusieurs pas physiques par frame visuelle pour accélérer
      for (let k = 0; k < stepsPerFrame; k++) {
        simulate();
      }
      render();
    }
    requestAnimationFrame(loop);
  }

  // Listeners UI
  document.getElementById("start-btn").addEventListener("click", () => {
    document.getElementById("startup-modal").style.display = "none";
    resizeGrid();
    loop();
  });

  // Sliders
  const inputs = ["mach", "aoa", "thickness", "camber", "contrast"];
  inputs.forEach(id => {
    const el = document.getElementById(id);
    const valDisplay = document.getElementById(id + "-val");
    
    el.addEventListener("input", (e) => {
      valDisplay.textContent = e.target.value + (id === "aoa" ? "°" : "");
      
      if (id === "contrast") {
        contrast = parseFloat(e.target.value);
        if(paused) render(); // Mettre à jour l'image si en pause
      } else if (id === "mach") {
        // Mach change juste u0, pas besoin de reset géométrie
        u0 = parseFloat(e.target.value) * 0.577;
      } else {
        // Changement géométrie -> Reset nécessaire pour propreté
        createAirfoil();
        // On nettoie le fluide DANS l'obstacle (facultatif mais propre)
        for(let i=0; i<Nx*Ny; i++) { if(mask[i]) { ux[i]=0; uy[i]=0; } }
      }
    });
  });

  document.getElementById("pause-btn").addEventListener("click", function() {
    paused = !paused;
    this.textContent = paused ? "Reprendre" : "Pause";
    this.classList.toggle("primary");
    this.classList.toggle("secondary");
  });

  document.getElementById("reset-btn").addEventListener("click", () => {
    initFluid();
  });

  window.addEventListener("resize", () => {
    // Optionnel: Redémarrer si la fenêtre change drastiquement
    // resizeGrid();
    // canvas.width = document.body.clientWidth;
    // canvas.height = document.body.clientHeight;
  });

</script>
</body>
</html>
