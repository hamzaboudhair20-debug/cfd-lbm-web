<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LBM Blue Stable</title>
  <style>
    /* =========================================
       STYLE UI: THÈME "DEEP BLUE" (Comme l'image)
       ========================================= */
    * { box-sizing: border-box; user-select: none; font-family: 'Segoe UI', sans-serif; }

    body {
      margin: 0; padding: 0;
      background-color: #000510; /* Fond très sombre bleu nuit */
      height: 100vh; overflow: hidden;
      display: flex; align-items: center; justify-content: center;
    }

    canvas {
      display: block; width: 100%; height: 100%;
      image-rendering: auto; /* Lissage activé pour un dégradé propre */
    }

    /* Panneau de contrôle Flottant */
    #controls {
      position: absolute;
      top: 30px; right: 30px;
      width: 320px;
      padding: 25px;
      
      /* Style Glassmorphism Bleu Sombre */
      background: rgba(10, 15, 40, 0.75);
      backdrop-filter: blur(15px);
      -webkit-backdrop-filter: blur(15px);
      border: 1px solid rgba(100, 150, 255, 0.1);
      box-shadow: 0 20px 60px rgba(0, 0, 10, 0.6);
      border-radius: 16px;
      z-index: 100;
      color: #fff;
    }

    #controls h2 {
      margin: 0 0 20px 0; font-size: 14px; font-weight: 700;
      color: #60a5fa; text-transform: uppercase; letter-spacing: 1px;
      border-bottom: 1px solid rgba(255,255,255,0.05);
      padding-bottom: 10px;
    }

    .control-group { margin-bottom: 18px; }

    .label-row {
      display: flex; justify-content: space-between;
      font-size: 11px; color: #94a3b8; margin-bottom: 8px;
      font-weight: 600;
    }

    .value-text { color: #fff; font-weight: 700; }

    /* Sliders bleus */
    input[type="range"] {
      width: 100%; height: 4px;
      background: rgba(255,255,255,0.1);
      border-radius: 2px; outline: none; -webkit-appearance: none; cursor: pointer;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px; height: 16px;
      background: #3b82f6; /* Bleu électrique */
      border: 2px solid #0f172a;
      border-radius: 50%; margin-top: -6px;
      box-shadow: 0 0 10px rgba(59, 130, 246, 0.6);
      transition: transform 0.1s;
    }
    input[type="range"]:hover::-webkit-slider-thumb { transform: scale(1.15); }

    .btn-row { display: flex; gap: 10px; margin-top: 25px; }

    button {
      flex: 1; padding: 10px; border: none; border-radius: 8px;
      font-size: 11px; font-weight: 600; cursor: pointer; text-transform: uppercase;
      transition: all 0.2s;
      background: rgba(255,255,255,0.08); color: #cbd5e1;
      border: 1px solid rgba(255,255,255,0.05);
    }
    button:hover { background: rgba(255,255,255,0.15); color: #fff; }
    
    .stats {
      margin-top: 15px; padding-top: 15px;
      border-top: 1px solid rgba(255,255,255,0.05);
      font-size: 10px; color: #506080; font-family: monospace;
      display: flex; justify-content: space-between;
    }

    /* Alerte Crash */
    #crash-alert {
      position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
      background: rgba(220, 38, 38, 0.9); color: white;
      padding: 10px 20px; border-radius: 30px; font-size: 12px; font-weight: bold;
      display: none; box-shadow: 0 5px 20px rgba(0,0,0,0.5); pointer-events: none;
    }
  </style>
</head>
<body>

  <canvas id="sim-canvas"></canvas>

  <div id="crash-alert">⚠️ Instabilité détectée - Redémarrage automatique</div>

  <div id="controls">
    <h2>LBM Channel Flow (LES)</h2>

    <div class="control-group">
      <div class="label-row"><span>Flow Speed (Mach)</span><span class="value-text" id="mach-val">0.12</span></div>
      <input type="range" id="mach" min="0.05" max="0.3" step="0.01" value="0.12">
    </div>

    <div class="control-group">
      <div class="label-row"><span>Viscosity (Stability)</span><span class="value-text" id="visc-val">0.030</span></div>
      <input type="range" id="viscosity" min="0.01" max="0.1" step="0.001" value="0.030">
    </div>

    <div class="control-group">
      <div class="label-row"><span>Angle of Attack</span><span class="value-text" id="aoa-val">8°</span></div>
      <input type="range" id="aoa" min="-20" max="20" step="1" value="8">
    </div>

    <div class="control-group">
      <div class="label-row"><span>Airfoil Thickness</span><span class="value-text" id="thick-val">0.12</span></div>
      <input type="range" id="thickness" min="0.02" max="0.20" step="0.01" value="0.12">
    </div>

    <div class="control-group">
      <div class="label-row"><span>Camber</span><span class="value-text" id="camber-val">0.05</span></div>
      <input type="range" id="camber" min="0" max="0.2" step="0.01" value="0.05">
    </div>

    <div class="control-group">
      <div class="label-row"><span>Contrast</span><span class="value-text" id="contrast-val">1.4</span></div>
      <input type="range" id="contrast" min="0.5" max="3.0" step="0.1" value="1.4">
    </div>

    <div class="btn-row">
      <button id="reset-btn">Reset Flow</button>
      <button id="pause-btn">Pause</button>
    </div>

    <div class="stats">
      <span id="step-count">Steps: 0</span>
      <span>Resolution: 400x200</span>
    </div>
  </div>

<script>
  // ======================================================
  // 1. MOTEUR LBM STABLE
  // ======================================================
  const canvas = document.getElementById("sim-canvas");
  const ctx = canvas.getContext("2d", { alpha: false }); // Optimisation

  // Paramètres Simulation
  const Nx = 400; 
  const Ny = 200;
  const Q = 9;
  
  // Paramètres Physiques (Valeurs par défaut stables)
  let viscosity = 0.03;
  let u0 = 0.1;  
  let contrast = 1.4;
  let stepsPerFrame = 8;
  let paused = false;
  let steps = 0;

  // Tableaux (TypedArrays)
  let f = new Float32Array(Nx * Ny * Q);
  let fNew = new Float32Array(Nx * Ny * Q);
  let rho = new Float32Array(Nx * Ny);
  let ux = new Float32Array(Nx * Ny);
  let uy = new Float32Array(Nx * Ny);
  let mask = new Uint8Array(Nx * Ny);
  
  // Buffer Image (Ecriture directe)
  let imageBuffer = new ArrayBuffer(Nx * Ny * 4);
  let imageData32 = new Uint32Array(imageBuffer);

  const w = [4/9, 1/9, 1/9, 1/9, 1/9, 1/36, 1/36, 1/36, 1/36];
  const cx = [0, 1, 0, -1, 0, 1, -1, -1, 1];
  const cy = [0, 0, 1, 0, -1, 1, 1, -1, -1];
  const opp = [0, 3, 4, 1, 2, 7, 8, 5, 6];

  // ======================================================
  // 2. GEOMETRIE JOUKOWSKY
  // ======================================================
  function createAirfoil() {
    mask.fill(0);
    const aoa = -parseFloat(document.getElementById("aoa").value) * Math.PI / 180;
    const thick = parseFloat(document.getElementById("thickness").value);
    const camb = parseFloat(document.getElementById("camber").value);
    
    const chord = Nx * 0.45;
    const cx0 = Nx * 0.35;
    const cy0 = Ny * 0.5;
    
    let poly = [];
    const nPoints = 300;
    
    // Paramètres cercle transformé
    const beta = camb * 2.0; 
    const epsilon = thick * 0.8;
    const R = Math.sqrt((1+epsilon)**2 + beta**2);
    const z0x = -epsilon;
    const z0y = beta;

    for(let i=0; i<nPoints; i++) {
      const theta = 2 * Math.PI * i / nPoints;
      const zx = z0x + R * Math.cos(theta);
      const zy = z0y + R * Math.sin(theta);
      
      const den = zx*zx + zy*zy;
      if(den < 0.001) continue;
      const wx = zx * (1 + 1/den);
      const wy = zy * (1 - 1/den);
      
      // Rotation et Translation
      const rx = (wx * Math.cos(aoa) - wy * Math.sin(aoa)) * (chord/4) + cx0;
      const ry = (wx * Math.sin(aoa) + wy * Math.cos(aoa)) * (chord/4) + cy0;
      poly.push({x: rx, y: ry});
    }

    // Remplissage (Scanline)
    for (let y = 0; y < Ny; y++) {
      for (let x = 0; x < Nx; x++) {
        let inside = false;
        for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
            const xi = poly[i].x, yi = poly[i].y;
            const xj = poly[j].x, yj = poly[j].y;
            const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
            if (intersect) inside = !inside;
        }
        if (inside) mask[x + y*Nx] = 1;
      }
    }
  }

  function init() {
    u0 = parseFloat(document.getElementById("mach").value) * 0.577;
    viscosity = parseFloat(document.getElementById("viscosity").value);
    
    // Reset fluide
    for(let i=0; i<Nx*Ny; i++) {
      rho[i] = 1.0;
      ux[i] = mask[i] ? 0 : u0;
      uy[i] = 0;
      
      const u2 = ux[i]*ux[i] + uy[i]*uy[i];
      for(let k=0; k<Q; k++) {
        const eu = cx[k]*ux[i] + cy[k]*uy[i];
        f[i*Q + k] = w[k] * rho[i] * (1 + 3*eu + 4.5*eu*eu - 1.5*u2);
      }
    }
    steps = 0;
    
    // Cacher l'alerte crash si elle était visible
    document.getElementById("crash-alert").style.display = "none";
  }

  // ======================================================
  // 3. BOUCLE PHYSIQUE + SÉCURITÉ
  // ======================================================
  function simulate() {
    const tau = 0.5 + 3 * viscosity;
    const omega = 1.0 / tau;
    let maxVel = 0;

    // Collision BGK
    for(let i=0; i<Nx*Ny; i++) {
      if(mask[i]) continue;

      let r = 0, u = 0, v = 0;
      const idx = i*Q;
      
      // Calcul Densité et Vitesse
      r = f[idx] + f[idx+1] + f[idx+2] + f[idx+3] + f[idx+4] + f[idx+5] + f[idx+6] + f[idx+7] + f[idx+8];
      u = (f[idx+1] - f[idx+3] + f[idx+5] - f[idx+6] - f[idx+7] + f[idx+8]) / r;
      v = (f[idx+2] - f[idx+4] + f[idx+5] + f[idx+6] - f[idx+7] - f[idx+8]) / r;
      
      // CHECK DE STABILITÉ (Anti-Crash)
      // Si la vitesse dépasse 0.8 (Mach approx) ou si NaN -> Reset
      if (isNaN(u) || Math.abs(u) > 0.8) {
        triggerCrashRecovery();
        return;
      }

      rho[i] = r; ux[i] = u; uy[i] = v;
      
      const u2 = u*u + v*v;
      // Relaxation
      for(let k=0; k<Q; k++) {
        const eu = cx[k]*u + cy[k]*v;
        const feq = w[k] * r * (1 + 3*eu + 4.5*eu*eu - 1.5*u2);
        f[idx+k] += omega * (feq - f[idx+k]);
      }
    }

    // Streaming
    for(let y=0; y<Ny; y++) {
      for(let x=0; x<Nx; x++) {
        const i = x + y*Nx;
        if(mask[i]) continue;

        for(let k=0; k<Q; k++) {
          const nx = x + cx[k];
          const ny = y + cy[k];
          
          if(nx >= 0 && nx < Nx && ny >= 0 && ny < Ny) {
            const ni = nx + ny*Nx;
            if(mask[ni]) {
              fNew[i*Q + opp[k]] = f[i*Q + k]; // Rebond
            } else {
              fNew[ni*Q + k] = f[i*Q + k]; // Propagation
            }
          }
        }
      }
    }

    // Inlet (Gauche)
    const u2in = u0*u0;
    for(let y=0; y<Ny; y++) {
      const i = y*Nx;
      if(!mask[i]) {
        for(let k=0; k<Q; k++) {
          const eu = cx[k]*u0;
          fNew[i*Q+k] = w[k] * 1.0 * (1 + 3*eu + 4.5*eu*eu - 1.5*u2in);
        }
      }
    }
    
    // Outlet (Droite) - Copie simple
    for(let y=0; y<Ny; y++) {
      const i = (Nx-1) + y*Nx;
      if(!mask[i]) {
        for(let k=0; k<Q; k++) fNew[i*Q+k] = fNew[(i-1)*Q+k];
      }
    }

    let t = f; f = fNew; fNew = t;
    steps++;
  }

  function triggerCrashRecovery() {
    const alert = document.getElementById("crash-alert");
    alert.style.display = "block";
    alert.textContent = "⚠️ Instabilité ! Ralentissement auto...";
    
    // Réduire la vitesse pour stabiliser
    const machInput = document.getElementById("mach");
    machInput.value = (parseFloat(machInput.value) * 0.8).toFixed(2);
    machInput.dispatchEvent(new Event("input"));
    
    init(); // Restart
    
    setTimeout(() => { alert.style.display = "none"; }, 2000);
  }

  // ======================================================
  // 4. RENDU VISUEL "DEEP BLUE" (MONOCHROMATIQUE)
  // ======================================================
  function render() {
    const maxSpeed = u0 * (2.2 / contrast); 

    for(let i=0; i<Nx*Ny; i++) {
      if(mask[i]) {
        // Obstacle BLANC LÉGÈREMENT GRIS (Antialiasing simulé)
        imageData32[i] = 0xFFEAEAEA; 
        continue;
      }

      const v = Math.sqrt(ux[i]*ux[i] + uy[i]*uy[i]);
      let t = v / maxSpeed;
      if(t > 1.0) t = 1.0;

      // PALETTE BLEUE PERSONNALISÉE
      // Fond: Bleu très sombre (R=0, G=10, B=40)
      // Milieu: Bleu Roi (R=20, G=80, B=200)
      // Haut: Cyan/Blanc (R=100, G=200, B=255)
      
      let r, g, b;

      if (t < 0.5) {
        // De Sombre à Bleu
        let localT = t * 2.0;
        r = Math.floor(0 + 20 * localT);
        g = Math.floor(10 + 70 * localT);
        b = Math.floor(40 + 160 * localT);
      } else {
        // De Bleu à Blanc/Cyan
        let localT = (t - 0.5) * 2.0;
        r = Math.floor(20 + 180 * localT);
        g = Math.floor(80 + 175 * localT);
        b = 255; // Reste bleu max
      }

      // ABGR format
      imageData32[i] = (255 << 24) | (b << 16) | (g << 8) | r;
    }

    ctx.putImageData(new ImageData(new Uint8ClampedArray(imageBuffer), Nx, Ny), 0, 0);
    document.getElementById("step-count").innerText = "Steps: " + steps;
  }

  // ======================================================
  // 5. UI & BOUCLE
  // ======================================================
  function resize() {
    canvas.width = Nx;
    canvas.height = Ny;
  }

  function loop() {
    if(!paused) {
      for(let k=0; k<stepsPerFrame; k++) simulate();
      render();
    }
    requestAnimationFrame(loop);
  }

  createAirfoil();
  init();
  resize();
  loop();

  // Gestion des inputs
  const inputs = ["mach", "viscosity", "aoa", "thickness", "camber", "contrast"];
  inputs.forEach(id => {
    const el = document.getElementById(id);
    el.addEventListener("input", (e) => {
      const val = e.target.value;
      const suffix = (id === "aoa") ? "°" : "";
      document.getElementById(id+"-val").innerText = val + suffix;
      
      if(id === "mach") {
        u0 = parseFloat(val) * 0.577;
      } else if(id === "viscosity") {
        viscosity = parseFloat(val);
      } else if(id === "contrast") {
        contrast = parseFloat(val);
        if(paused) render();
      } else {
        createAirfoil();
        for(let i=0; i<Nx*Ny; i++) if(mask[i]) { ux[i]=0; uy[i]=0; }
      }
    });
  });

  document.getElementById("reset-btn").addEventListener("click", init);
  document.getElementById("pause-btn").addEventListener("click", function() {
    paused = !paused;
    this.innerText = paused ? "Resume" : "Pause";
  });

</script>
</body>
</html>
