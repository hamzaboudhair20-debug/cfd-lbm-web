<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>LBM Smoke Effect</title>
  <style>
    /* ============================
       STYLE UI / CADRE INCHANG√â
       ============================ */
    * {
      box-sizing: border-box;
      user-select: none;
      font-family: 'Segoe UI', sans-serif;
    }

    body {
      margin: 0;
      background: #000;
      height: 100vh;
      overflow: hidden;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    #controls {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 280px;
      padding: 20px;
      background: rgba(0, 0, 0, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      color: #fff;
    }

    h2 {
      margin: 0 0 15px 0;
      font-size: 12px;
      color: #22d3ee;
      text-transform: uppercase;
      letter-spacing: 2px;
      font-weight: 800;
    }

    .group {
      margin-bottom: 12px;
    }

    .labels {
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      color: #9ca3af;
      margin-bottom: 4px;
      font-weight: 600;
      text-transform: uppercase;
    }

    input[type="range"] {
      width: 100%;
      height: 4px;
      background: #333;
      border-radius: 2px;
      outline: none;
      -webkit-appearance: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 12px;
      height: 12px;
      background: #22d3ee;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid #000;
    }

    .btns {
      display: flex;
      gap: 8px;
      margin-top: 20px;
    }

    button {
      flex: 1;
      padding: 10px;
      background: #222;
      border: 1px solid #444;
      color: #22d3ee;
      border-radius: 6px;
      cursor: pointer;
      font-size: 10px;
      font-weight: bold;
      text-transform: uppercase;
    }

    button:hover {
      background: #333;
      color: #fff;
    }

    .hint {
      position: absolute;
      bottom: 20px;
      left: 20px;
      color: rgba(255, 255, 255, 0.4);
      font-size: 12px;
      pointer-events: none;
    }
  </style>
</head>
<body>

<canvas id="c"></canvas>
<div class="hint">üñ±Ô∏è Glisser pour bouger l'aile</div>

<div id="controls">
  <h2>Smoke Tunnel</h2>

  <div class="group">
    <div class="labels">
      <span>Speed</span><span id="v-mach" class="val">0.15</span>
    </div>
    <input type="range" id="mach" min="0.00" max="0.4" step="0.01" value="0.15">
  </div>

  <div class="group">
    <div class="labels">
      <span>Viscosity (Smoke Detail)</span><span id="v-visc" class="val">0.015</span>
    </div>
    <input type="range" id="visc" min="0.005" max="0.1" step="0.001" value="0.015">
  </div>

  <div class="group">
    <div class="labels">
      <span>Angle</span><span id="v-aoa" class="val">12¬∞</span>
    </div>
    <input type="range" id="aoa" min="-180" max="180" step="1" value="12">
  </div>

  <div class="group">
    <div class="labels">
      <span>Contrast</span><span id="v-cont" class="val">2.0</span>
    </div>
    <input type="range" id="cont" min="1.0" max="5.0" step="0.1" value="2.0">
  </div>

  <div class="btns">
    <button id="rst">Reset</button>
    <button id="pse">Pause</button>
  </div>
</div>

<script>
  // ======================================================
  // 1. CONFIGURATION & CONSTANTES
  // ======================================================
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });

  // R√©solution interne (fixe) du domaine LBM
  const Nx = 400;
  const Ny = 200;
  const Q  = 9;

  // Directions du sch√©ma D2Q9
  const W = [4/9, 1/9, 1/9, 1/9, 1/9, 1/36, 1/36, 1/36, 1/36];
  const CX = [0, 1, 0, -1, 0,  1, -1, -1, 1];
  const CY = [0, 0, 1,  0,-1,  1,  1, -1,-1];
  const OPP = [0, 3, 4, 1, 2, 7, 8, 5, 6];

  // √âtat physique / param√®tres ajustables
  let viscosity = 0.015;   // ŒΩ, tr√®s faible pour voir des structures fines
  let u0        = 0.1;     // vitesse d‚Äôentr√©e (en unit√©s lattice)
  let contrast  = 2.0;     // contraste de la fum√©e
  let running   = true;    // pause / lecture

  // Position du profil (d√©pla√ßable √† la souris)
  let airfoilX = Nx * 0.25;
  let airfoilY = Ny * 0.5;
  let isDragging = false;

  // ======================================================
  // 2. TABLEAUX LBM & RENDU
  // ======================================================
  const size = Nx * Ny;

  // Fonctions de distribution
  let f    = new Float32Array(size * Q);
  let fNew = new Float32Array(size * Q);

  // Grandeurs macroscopiques
  let rho = new Float32Array(size);
  let ux  = new Float32Array(size);
  let uy  = new Float32Array(size);

  // Masque de g√©om√©trie (1 = solide, 0 = fluide)
  let mask = new Uint8Array(size);

  // Buffer d‚Äôimage (ABGR 32 bits)
  const imgBuf = new ArrayBuffer(size * 4);
  const img32  = new Uint32Array(imgBuf);

  // Chemin canvas pour dessiner le profil
  let airfoilPath = new Path2D();

  // ======================================================
  // 3. G√âOM√âTRIE : PROFIL DE JOUKOWSKY + MASQUE
  // ======================================================
  function buildGeometry() {
    mask.fill(0);
    airfoilPath = new Path2D();

    const aoaDeg = parseFloat(document.getElementById('aoa').value);
    const aoa    = -aoaDeg * Math.PI / 180;  // rotation du profil

    const chord = Nx * 0.4;  // longueur de corde en pixels lattice

    // Param√®tres ‚Äúcercle g√©n√©rateur‚Äù pour un profil assez fin
    const thickness = 0.12;
    const camber    = 0.10;
    const beta      = 2.0 * camber;
    const eps       = thickness * 0.8;

    const R   = Math.sqrt((1 + eps) ** 2 + beta ** 2);
    const z0x = -eps;
    const z0y =  beta;

    const Np = 200;
    const pts = [];

    // Contour du profil via transformation de Joukowsky
    for (let i = 0; i <= Np; i++) {
      const theta = (2 * Math.PI * i) / Np;

      const zx = z0x + R * Math.cos(theta);
      const zy = z0y + R * Math.sin(theta);
      let denom = zx * zx + zy * zy;
      if (denom < 1e-3) denom = 1e-3;

      const wx = zx * (1 + 1 / denom);
      const wy = zy * (1 - 1 / denom);

      // Rotation + mise √† l‚Äô√©chelle + translation dans le domaine
      const xr = (wx * Math.cos(aoa) - wy * Math.sin(aoa)) * (chord / 4) + airfoilX;
      const yr = (wx * Math.sin(aoa) + wy * Math.cos(aoa)) * (chord / 4) + airfoilY;

      pts.push({ x: xr, y: yr });
    }

    // Bornes pour limiter le remplissage
    let minX = Nx, maxX = 0, minY = Ny, maxY = 0;
    for (const p of pts) {
      if (p.x < minX) minX = p.x;
      if (p.x > maxX) maxX = p.x;
      if (p.y < minY) minY = p.y;
      if (p.y > maxY) maxY = p.y;
    }
    minX = Math.max(0, Math.floor(minX));
    maxX = Math.min(Nx, Math.ceil(maxX));
    minY = Math.max(0, Math.floor(minY));
    maxY = Math.min(Ny, Math.ceil(maxY));

    // Remplissage polygonal (ray casting) pour le masque solide
    for (let y = minY; y < maxY; y++) {
      for (let x = minX; x < maxX; x++) {
        let inside = false;
        for (let i = 0, j = Np - 1; i < Np; j = i++) {
          const pi = pts[i], pj = pts[j];
          const intersect = ((pi.y > y) !== (pj.y > y)) &&
                            (x < (pj.x - pi.x) * (y - pi.y) / (pj.y - pi.y) + pi.x);
          if (intersect) inside = !inside;
        }
        if (inside) {
          mask[x + y * Nx] = 1;
        }
      }
    }

    // Construction du Path2D pour affichage
    airfoilPath.moveTo(pts[0].x, pts[0].y);
    for (let i = 1; i < pts.length; i++) {
      airfoilPath.lineTo(pts[i].x, pts[i].y);
    }
    airfoilPath.closePath();
  }

  // ======================================================
  // 4. INITIALISATION LBM
  // ======================================================
  function initLBM() {
    // vitesse d‚Äôentr√©e (Mach * c_s, c_s ‚âà 1/‚àö3 ‚âà 0.577)
    const machSlider = parseFloat(document.getElementById('mach').value);
    u0        = machSlider * 0.577;
    viscosity = parseFloat(document.getElementById('visc').value);
    contrast  = parseFloat(document.getElementById('cont').value);

    for (let i = 0; i < size; i++) {
      rho[i] = 1.0;
      ux[i]  = mask[i] ? 0.0 : u0;
      uy[i]  = 0.0;

      const u2 = ux[i] * ux[i] + uy[i] * uy[i];
      const base = rho[i];

      const idx = i * Q;
      for (let k = 0; k < Q; k++) {
        const eu = CX[k] * ux[i] + CY[k] * uy[i];
        f[idx + k] = W[k] * base * (1 + 3 * eu + 4.5 * eu * eu - 1.5 * u2);
      }
    }
  }

  // ======================================================
  // 5. UNE √âTAPE LBM : COLLISION + STREAMING + C.L.
  // ======================================================
  function lbmStep() {
    const tau = 0.5 + 3 * viscosity;
    const omega = 1.0 / tau;

    // ---------- Collision + calcul œÅ, u ----------
    for (let i = 0; i < size; i++) {
      if (mask[i]) continue;

      const idx = i * Q;

      // densit√©
      let r = 0;
      for (let k = 0; k < Q; k++) r += f[idx + k];

      let u = (
        f[idx + 1] - f[idx + 3] +
        f[idx + 5] - f[idx + 6] -
        f[idx + 7] + f[idx + 8]
      ) / r;

      let v = (
        f[idx + 2] - f[idx + 4] +
        f[idx + 5] + f[idx + 6] -
        f[idx + 7] - f[idx + 8]
      ) / r;

      // garde-fou num√©rique
      if (!Number.isFinite(u) || Math.abs(u) > 1.0 || !Number.isFinite(r) || r <= 0) {
        initLBM();
        return;
      }

      rho[i] = r;
      ux[i]  = u;
      uy[i]  = v;

      const u2 = u * u + v * v;

      // relaxation BGK
      for (let k = 0; k < Q; k++) {
        const eu  = CX[k] * u + CY[k] * v;
        const feq = W[k] * r * (1 + 3 * eu + 4.5 * eu * eu - 1.5 * u2);
        f[idx + k] += omega * (feq - f[idx + k]);
      }
    }

    // ---------- Streaming + bounce-back ----------
    fNew.fill(0);

    for (let y = 0; y < Ny; y++) {
      for (let x = 0; x < Nx; x++) {
        const i = x + y * Nx;
        if (mask[i]) continue;

        const idx = i * Q;
        for (let k = 0; k < Q; k++) {
          const nx = x + CX[k];
          const ny = y + CY[k];

          if (nx >= 0 && nx < Nx && ny >= 0 && ny < Ny) {
            const ni = nx + ny * Nx;
            const nIdx = ni * Q;

            if (mask[ni]) {
              // rebond instantan√© sur mur
              fNew[idx + OPP[k]] = f[idx + k];
            } else {
              fNew[nIdx + k] = f[idx + k];
            }
          }
        }
      }
    }

    // ---------- Conditions aux limites entr√©e / sortie ----------
    const u2in = u0 * u0;

    // entr√©e √† gauche (profil de vitesse uniforme)
    for (let y = 0; y < Ny; y++) {
      const i = y * Nx;
      if (mask[i]) continue;

      const idx = i * Q;
      for (let k = 0; k < Q; k++) {
        const eu = CX[k] * u0;
        fNew[idx + k] = W[k] * (1 + 3 * eu + 4.5 * eu * eu - 1.5 * u2in);
      }
    }

    // sortie √† droite : extrapolation simple
    for (let y = 0; y < Ny; y++) {
      const iRight = (Nx - 1) + y * Nx;
      const iLeft  = (Nx - 2) + y * Nx;
      if (mask[iRight]) continue;

      const idxR = iRight * Q;
      const idxL = iLeft  * Q;
      for (let k = 0; k < Q; k++) {
        fNew[idxR + k] = fNew[idxL + k];
      }
    }

    // swap des buffers
    const tmp = f;
    f = fNew;
    fNew = tmp;
  }

  // ======================================================
  // 6. RENDU ‚ÄúSMOKE / INK‚Äù BAS√â SUR LA VORTICIT√â
  // ======================================================
  function renderSmoke() {
    // calcul local de la vorticit√© + intensit√© de fum√©e
    for (let y = 1; y < Ny - 1; y++) {
      for (let x = 1; x < Nx - 1; x++) {
        const i = x + y * Nx;

        if (mask[i]) {
          // obstacle (ailes) = noir plein
          img32[i] = 0xFF000000;
          continue;
        }

        // œâz ‚âà du/dy - dv/dx (sch√©ma central 1er ordre)
        const du_dy = ux[i + Nx] - ux[i - Nx];
        const dv_dx = uy[i + 1]  - uy[i - 1];
        const curl  = du_dy - dv_dx;

        const speed = Math.hypot(ux[i], uy[i]);
        let val     = Math.abs(curl * 5.0) + speed * 0.2;

        val *= contrast;
        if (val > 1.0) val = 1.0;

        // palette cyan/blanc sur fond noir
        const r = Math.floor(val * 150);
        const g = Math.floor(val * 240);
        const b = Math.floor(val * 255);

        img32[i] = (255 << 24) | (b << 16) | (g << 8) | r;
      }
    }

    // Conversion vers ImageData et dessin mis √† l‚Äô√©chelle
    const imgData = new ImageData(new Uint8ClampedArray(imgBuf), Nx, Ny);

    createImageBitmap(imgData).then(bitmap => {
      const Wview = canvas.width  = window.innerWidth;
      const Hview = canvas.height = window.innerHeight;

      ctx.imageSmoothingEnabled  = true;
      ctx.imageSmoothingQuality  = 'high';

      ctx.fillStyle = 'black';
      ctx.fillRect(0, 0, Wview, Hview);

      // champ fum√©e
      ctx.drawImage(bitmap, 0, 0, Wview, Hview);

      // aile par-dessus
      const scaleX = Wview / Nx;
      const scaleY = Hview / Ny;

      ctx.save();
      ctx.scale(scaleX, scaleY);
      ctx.fillStyle   = '#000';
      ctx.strokeStyle = '#22d3ee';
      ctx.lineWidth   = 1.5 / scaleX;
      ctx.fill(airfoilPath);
      ctx.stroke(airfoilPath);
      ctx.restore();
    });
  }

  // ======================================================
  // 7. BOUCLE PRINCIPALE
  // ======================================================
  function loop() {
    if (running) {
      // plusieurs pas LBM par frame pour un √©coulement plus rapide
      for (let k = 0; k < 8; k++) lbmStep();
      renderSmoke();
    }
    requestAnimationFrame(loop);
  }

  // ======================================================
  // 8. INTERACTIONS UI (SLIDERS + DRAG PROFIL)
  // ======================================================
  function bindUI() {
    const sliders = ['mach', 'visc', 'aoa', 'cont'];

    sliders.forEach(id => {
      const slider   = document.getElementById(id);
      const label    = document.getElementById('v-' + id);

      slider.addEventListener('input', () => {
        const val = slider.value;
        label.textContent = val + (id === 'aoa' ? '¬∞' : '');

        if (id === 'mach') {
          u0 = parseFloat(val) * 0.577;
        } else if (id === 'visc') {
          viscosity = parseFloat(val);
        } else if (id === 'cont') {
          contrast = parseFloat(val);
        } else if (id === 'aoa') {
          // angle ‚Üí on reconstruit la g√©om√©trie
          buildGeometry();
          // on remet proprement les cellules solides
          for (let i = 0; i < size; i++) {
            if (mask[i]) {
              ux[i] = 0;
              uy[i] = 0;
              rho[i] = 1;
            }
          }
        }
      });
    });

    // D√©placement du profil √† la souris
    canvas.addEventListener('mousedown', e => {
      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (Nx / canvas.width);
      const my = (e.clientY - rect.top)  * (Ny / canvas.height);
      const dist2 = (mx - airfoilX) ** 2 + (my - airfoilY) ** 2;
      if (dist2 < 30 * 30) {
        isDragging = true;
      }
    });

    window.addEventListener('mousemove', e => {
      if (!isDragging) return;

      const rect = canvas.getBoundingClientRect();
      airfoilX = Math.max(20, Math.min(Nx - 20,
        (e.clientX - rect.left) * (Nx / canvas.width)
      ));
      airfoilY = Math.max(20, Math.min(Ny - 20,
        (e.clientY - rect.top) * (Ny / canvas.height)
      ));

      buildGeometry();
      for (let i = 0; i < size; i++) {
        if (mask[i]) {
          ux[i]  = 0;
          uy[i]  = 0;
          rho[i] = 1;
        }
      }
    });

    window.addEventListener('mouseup', () => {
      isDragging = false;
    });

    // Boutons Reset / Pause
    document.getElementById('rst').addEventListener('click', () => {
      initLBM();
    });

    document.getElementById('pse').addEventListener('click', () => {
      running = !running;
      document.getElementById('pse').textContent = running ? 'Pause' : 'Resume';
    });
  }

  // ======================================================
  // 9. LANCEMENT
  // ======================================================
  buildGeometry();
  initLBM();
  bindUI();
  loop();
</script>

</body>
</html>
