<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>LBM D2Q9 – GPU Web CFD Prototype</title>

  <style>
    * { box-sizing: border-box; }

    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #0b1120;
      color: #e5e7eb;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 12px 20px;
      border-bottom: 1px solid #1f2937;
      background: #020617;
    }

    header h1 {
      font-size: 20px;
      margin: 0;
    }

    header p {
      margin: 4px 0 0;
      font-size: 13px;
      color: #9ca3af;
    }

    main.layout {
      flex: 1;
      display: flex;
      min-height: 0;
    }

    #sim-container {
      flex: 3;
      background: #020617;
      display: flex;
      justify-content: center;
      align-items: center;
      border-right: 1px solid #1f2937;
      position: relative;
    }

    .canvas-stack {
      position: relative;
      width: 900px;
      height: 450px;
    }

    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: block;
    }

    #fluid-canvas {
      border: 1px solid #4b5563;
      background: #000;
      z-index: 1;
    }

    #airfoil-canvas {
      z-index: 2;
      pointer-events: none; /* la souris passe à travers */
    }

    #controls {
      flex: 1;
      padding: 20px;
      background: #030712;
      color: #e5e7eb;
      overflow-y: auto;
    }

    #controls h2 {
      margin-top: 0;
      margin-bottom: 12px;
      font-size: 18px;
    }

    .control {
      margin-bottom: 16px;
      font-size: 13px;
    }

    .control span.label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 4px;
    }

    .control span.value {
      color: #93c5fd;
      font-variant-numeric: tabular-nums;
      margin-left: 8px;
    }

    input[type="range"] {
      width: 100%;
    }

    .buttons {
      display: flex;
      gap: 8px;
      margin-top: 12px;
    }

    button {
      flex: 1;
      padding: 8px 10px;
      border-radius: 6px;
      border: 1px solid #1d4ed8;
      background: #1d4ed8;
      color: white;
      font-size: 13px;
      cursor: pointer;
    }

    button.secondary {
      background: transparent;
      border-color: #4b5563;
    }

    button:hover { filter: brightness(1.1); }

    footer {
      padding: 6px 16px;
      font-size: 11px;
      color: #6b7280;
      border-top: 1px solid #1f2937;
      background: #020617;
      text-align: right;
    }
  </style>
</head>

<body>
  <header>
    <h1>2D GPU CFD Prototype – Joukowsky Airfoil + WebGL Field</h1>
    <p>
      WebGL2 ping-pong shader field (GPU) + parametric Joukowsky airfoil overlay.
      Sliders control both geometry and shader dynamics (préfiguration LBM/LES).
    </p>
  </header>

  <main class="layout">
    <!-- Zone de simulation -->
    <section id="sim-container">
      <div class="canvas-stack">
        <!-- Canvas utilisé par WebGL (GPU) -->
        <canvas id="fluid-canvas" width="900" height="450"></canvas>
        <!-- Canvas 2D au-dessus pour dessiner le profil -->
        <canvas id="airfoil-canvas" width="900" height="450"></canvas>
      </div>
    </section>

    <!-- Panneau de contrôle -->
    <aside id="controls">
      <h2>Simulation Parameters</h2>

      <div class="control">
        <span class="label">
          <span>Flow Speed (Mach)</span>
          <span class="value" id="mach-value">0.20</span>
        </span>
        <input type="range" id="mach" min="0.02" max="0.40" step="0.01" value="0.20">
      </div>

      <div class="control">
        <span class="label">
          <span>Relaxation Time τ (numerical viscosity)</span>
          <span class="value" id="tau-value">0.80</span>
        </span>
        <input type="range" id="tau" min="0.51" max="1.20" step="0.01" value="0.80">
      </div>

      <div class="control">
        <span class="label">
          <span>Smagorinsky Constant C<sub>s</sub></span>
          <span class="value" id="cs-value">0.16</span>
        </span>
        <input type="range" id="cs" min="0.05" max="0.25" step="0.01" value="0.16">
      </div>

      <div class="control">
        <span class="label">
          <span>Angle of Attack (deg)</span>
          <span class="value" id="aoa-value">5°</span>
        </span>
        <input type="range" id="aoa" min="-10" max="25" step="1" value="5">
      </div>

      <div class="control">
        <span class="label">
          <span>Airfoil Thickness (t/c)</span>
          <span class="value" id="thickness-value">0.12</span>
        </span>
        <input type="range" id="thickness" min="0.06" max="0.18" step="0.01" value="0.12">
      </div>

      <div class="control">
        <span class="label">
          <span>Camber</span>
          <span class="value" id="camber-value">0.08</span>
        </span>
        <input type="range" id="camber" min="0.00" max="0.20" step="0.01" value="0.08">
      </div>

      <div class="buttons">
        <button id="reset-btn" class="secondary">Reset Field</button>
        <button id="pause-btn">Pause</button>
      </div>

      <p style="margin-top:16px; font-size:11px; color:#9ca3af;">
        Le champ coloré est calculé sur GPU via WebGL2 (ping-pong textures).
        Il simule un champ transporté/diffusé stylisé contrôlé par Mach, τ et C<sub>s</sub>.
        Le profil blanc est un airfoil de Joukowsky paramétrique (camber, épaisseur, AoA).
        Plus tard tu pourras remplacer le shader par un vrai noyau LBM D2Q9/LES.
      </p>
    </aside>
  </main>

  <footer>
    Prototype by Hamza – GPU Web CFD sandbox (GitHub Pages)
  </footer>

  <script>
    // -----------------------
    // 1) Utilitaires WebGL2
    // -----------------------
    const fluidCanvas = document.getElementById("fluid-canvas");
    const gl = fluidCanvas.getContext("webgl2");

    if (!gl) {
      alert("WebGL2 n'est pas supporté par ce navigateur. Essaie avec Chrome/Edge/Firefox récents.");
    }

    const W = fluidCanvas.width;
    const H = fluidCanvas.height;

    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    function createProgram(gl, vsSource, fsSource) {
      const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
      const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
      const prog = gl.createProgram();
      gl.attachShader(prog, vs);
      gl.attachShader(prog, fs);
      gl.linkProgram(prog);
      if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(prog));
        gl.deleteProgram(prog);
        return null;
      }
      return prog;
    }

    // Fullscreen quad
    const quadVBO = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, quadVBO);
    const quadVerts = new Float32Array([
      -1, -1,
       1, -1,
      -1,  1,
      -1,  1,
       1, -1,
       1,  1
    ]);
    gl.bufferData(gl.ARRAY_BUFFER, quadVerts, gl.STATIC_DRAW);

    // -----------------------
    // 2) Shaders (simulation + display)
    // -----------------------
    const vsSource = `#version 300 es
      precision highp float;
      in vec2 a_position;
      out vec2 v_uv;
      void main() {
        v_uv = 0.5 * (a_position + 1.0);
        gl_Position = vec4(a_position, 0.0, 1.0);
      }
    `;

    // Shader de simulation : diffusion + léger "forcing" sinus → similaire à une étape LBM lissée
    const simFS = `#version 300 es
      precision highp float;
      in vec2 v_uv;
      out vec4 outColor;

      uniform sampler2D u_prev;
      uniform vec2 u_resolution;
      uniform float u_diffusion;
      uniform float u_time;
      uniform float u_mach;
      uniform float u_cs;

      void main() {
        vec2 texel = 1.0 / u_resolution;

        float c  = texture(u_prev, v_uv).r;
        float up = texture(u_prev, v_uv + vec2(0.0,  texel.y)).r;
        float dn = texture(u_prev, v_uv + vec2(0.0, -texel.y)).r;
        float rt = texture(u_prev, v_uv + vec2( texel.x, 0.0)).r;
        float lt = texture(u_prev, v_uv + vec2(-texel.x, 0.0)).r;

        // Laplacien (diffusion)
        float lap = (up + dn + rt + lt - 4.0 * c);

        // "advection" / forcing stylisé (onde se déplaçant avec Mach)
        float wave = sin(12.0 * (v_uv.x + u_mach * u_time * 0.3) +
                         8.0  * (v_uv.y) -
                         0.5  * u_time);

        float next = c + u_diffusion * lap + 0.02 * wave * (0.5 + 2.0 * u_cs);

        // Légère dissipation numérique pour éviter les explosions
        next = mix(next, 0.5, 0.002);

        outColor = vec4(next, 0.0, 0.0, 1.0);
      }
    `;

    // Shader d'affichage : mapping scalaire → colormap
    const displayFS = `#version 300 es
      precision highp float;
      in vec2 v_uv;
      out vec4 outColor;
      uniform sampler2D u_field;

      vec3 colormap(float x) {
        // clamp
        x = clamp(x, 0.0, 1.0);
        // bleu → cyan → vert → jaune → rouge
        vec3 c1 = vec3(0.231, 0.298, 0.753); // bleu
        vec3 c2 = vec3(0.865, 0.865, 0.865); // clair
        vec3 c3 = vec3(0.706, 0.016, 0.150); // rouge
        if (x < 0.5) {
          float t = x / 0.5;
          return mix(c1, c2, t);
        } else {
          float t = (x - 0.5) / 0.5;
          return mix(c2, c3, t);
        }
      }

      void main() {
        float v = texture(u_field, v_uv).r;
        // recentrer autour de 0.5
        v = 0.5 + 0.5 * (v - 0.5) * 1.4;
        vec3 col = colormap(v);
        outColor = vec4(col, 1.0);
      }
    `;

    const simProgram = createProgram(gl, vsSource, simFS);
    const displayProgram = createProgram(gl, vsSource, displayFS);

    // -----------------------
    // 3) Textures ping-pong
    // -----------------------
    function createFieldTexture() {
      const tex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

      // init champ avec bruit doux autour de 0.5
      const data = new Float32Array(W * H * 4);
      for (let i = 0; i < W * H; i++) {
        const v = 0.5 + 0.05 * (Math.random() - 0.5);
        data[4 * i + 0] = v;
        data[4 * i + 1] = 0.0;
        data[4 * i + 2] = 0.0;
        data[4 * i + 3] = 1.0;
      }
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, W, H, 0, gl.RGBA, gl.FLOAT, data);
      return tex;
    }

    // Vérifier support des textures float
    if (!gl.getExtension("EXT_color_buffer_float")) {
      console.warn("EXT_color_buffer_float non disponible, le rendu peut être moins bon.");
    }

    const fieldTexA = createFieldTexture();
    const fieldTexB = createFieldTexture();

    const fboA = gl.createFramebuffer();
    const fboB = gl.createFramebuffer();

    function attachTextureToFBO(fbo, tex) {
      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }

    attachTextureToFBO(fboA, fieldTexA);
    attachTextureToFBO(fboB, fieldTexB);

    let readTex = fieldTexA;
    let writeTex = fieldTexB;
    let writeFBO = fboB;

    // -----------------------
    // 4) Gestion sliders & états
    // -----------------------
    let paused = false;
    let startTime = performance.now();
    let resetRequested = false;

    function bindSlider(sliderId, valueId, formatter) {
      const slider = document.getElementById(sliderId);
      const valueSpan = document.getElementById(valueId);
      if (!slider || !valueSpan) return;

      function update() {
        const v = parseFloat(slider.value);
        valueSpan.textContent = formatter ? formatter(v) : v.toFixed(2);
      }
      slider.addEventListener("input", update);
      update();
    }

    bindSlider("mach", "mach-value", v => v.toFixed(2));
    bindSlider("tau", "tau-value", v => v.toFixed(2));
    bindSlider("cs", "cs-value", v => v.toFixed(2));
    bindSlider("aoa", "aoa-value", v => v.toFixed(0) + "°");
    bindSlider("thickness", "thickness-value", v => v.toFixed(2));
    bindSlider("camber", "camber-value", v => v.toFixed(2));

    document.getElementById("pause-btn").addEventListener("click", () => {
      paused = !paused;
      document.getElementById("pause-btn").textContent = paused ? "Resume" : "Pause";
    });

    document.getElementById("reset-btn").addEventListener("click", () => {
      resetRequested = true;
    });

    // -----------------------
    // 5) Airfoil Joukowsky (canvas 2D overlay)
    // -----------------------
    const airfoilCanvas = document.getElementById("airfoil-canvas");
    const airCtx = airfoilCanvas.getContext("2d");
    let airfoilPoints = [];

    function recomputeAirfoil() {
      const aoaDeg = parseFloat(document.getElementById("aoa").value);
      const thickness = parseFloat(document.getElementById("thickness").value);
      const camber = parseFloat(document.getElementById("camber").value);

      const angle = aoaDeg * Math.PI / 180.0;
      const cosA = Math.cos(angle);
      const sinA = Math.sin(angle);

      const N = 400;
      const circleOffset = 0.08 + camber * 0.35;
      let radius = 1.0 - thickness * 0.6;
      if (radius < 0.25) radius = 0.25;

      let pts = [];
      for (let k = 0; k < N; k++) {
        const theta = 2 * Math.PI * k / N;
        const zx = circleOffset + radius * Math.cos(theta);
        const zy = radius * Math.sin(theta);

        const denom = zx * zx + zy * zy;
        const invx = zx / denom;
        const invy = -zy / denom;

        let x = zx + invx;
        let y = zy + invy;

        const xr = x * cosA - y * sinA;
        const yr = x * sinA + y * cosA;

        pts.push({ x: xr, y: yr });
      }

      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
      for (const p of pts) {
        if (p.x < minX) minX = p.x;
        if (p.x > maxX) maxX = p.x;
        if (p.y < minY) minY = p.y;
        if (p.y > maxY) maxY = p.y;
      }

      const spanX = maxX - minX;
      const spanY = maxY - minY;
      const midX = 0.5 * (maxX + minX);
      const midY = 0.5 * (maxY + minY);

      const scale = 0.55 * Math.min(W / spanX, H / spanY);
      const centerX = W * 0.30;
      const centerY = H * 0.50;

      airfoilPoints = pts.map(p => {
        const sx = (p.x - midX) * scale;
        const sy = (p.y - midY) * scale;
        return {
          x: centerX + sx,
          y: centerY - sy
        };
      });

      drawAirfoil();
    }

    function drawAirfoil() {
      airCtx.clearRect(0, 0, W, H);
      if (airfoilPoints.length === 0) return;

      airCtx.save();
      airCtx.fillStyle = "#e5e7eb";
      airCtx.strokeStyle = "#000000";
      airCtx.lineWidth = 1;

      airCtx.beginPath();
      airCtx.moveTo(airfoilPoints[0].x, airfoilPoints[0].y);
      for (let i = 1; i < airfoilPoints.length; i++) {
        airCtx.lineTo(airfoilPoints[i].x, airfoilPoints[i].y);
      }
      airCtx.closePath();
      airCtx.fill();
      airCtx.stroke();
      airCtx.restore();
    }

    ["aoa", "thickness", "camber"].forEach(id => {
      document.getElementById(id).addEventListener("input", () => {
        recomputeAirfoil();
      });
    });

    recomputeAirfoil();

    // -----------------------
    // 6) Boucle principale GPU
    // -----------------------
    function resetFieldTexture(tex) {
      gl.bindTexture(gl.TEXTURE_2D, tex);
      const data = new Float32Array(W * H * 4);
      for (let i = 0; i < W * H; i++) {
        const v = 0.5 + 0.05 * (Math.random() - 0.5);
        data[4 * i + 0] = v;
        data[4 * i + 1] = 0.0;
        data[4 * i + 2] = 0.0;
        data[4 * i + 3] = 1.0;
      }
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, W, H, 0, gl.RGBA, gl.FLOAT, data);
    }

    function stepGPU(now) {
      const time = (now - startTime) * 0.001;

      if (resetRequested) {
        resetFieldTexture(fieldTexA);
        resetFieldTexture(fieldTexB);
        resetRequested = false;
      }

      const mach = parseFloat(document.getElementById("mach").value);
      const tau  = parseFloat(document.getElementById("tau").value);
      const cs   = parseFloat(document.getElementById("cs").value);

      const diffusion = Math.max(0.0005, (tau - 0.5) * 0.02);

      gl.viewport(0, 0, W, H);
      gl.bindBuffer(gl.ARRAY_BUFFER, quadVBO);

      // 1) Étape simulation : render vers writeFBO
      if (!paused) {
        gl.useProgram(simProgram);

        const posLoc = gl.getAttribLocation(simProgram, "a_position");
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

        gl.bindFramebuffer(gl.FRAMEBUFFER, writeFBO);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, readTex);
        gl.uniform1i(gl.getUniformLocation(simProgram, "u_prev"), 0);
        gl.uniform2f(gl.getUniformLocation(simProgram, "u_resolution"), W, H);
        gl.uniform1f(gl.getUniformLocation(simProgram, "u_diffusion"), diffusion);
        gl.uniform1f(gl.getUniformLocation(simProgram, "u_time"), time);
        gl.uniform1f(gl.getUniformLocation(simProgram, "u_mach"), mach);
        gl.uniform1f(gl.getUniformLocation(simProgram, "u_cs"), cs);

        gl.drawArrays(gl.TRIANGLES, 0, 6);

        // ping-pong
        const tmpTex = readTex;
        readTex = writeTex;
        writeTex = tmpTex;
        writeFBO = (writeFBO === fboA) ? fboB : fboA;
      }

      // 2) Étape display : vers l'écran
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.useProgram(displayProgram);

      const posLoc2 = gl.getAttribLocation(displayProgram, "a_position");
      gl.enableVertexAttribArray(posLoc2);
      gl.vertexAttribPointer(posLoc2, 2, gl.FLOAT, false, 0, 0);

      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, readTex);
      gl.uniform1i(gl.getUniformLocation(displayProgram, "u_field"), 0);

      gl.drawArrays(gl.TRIANGLES, 0, 6);

      requestAnimationFrame(stepGPU);
    }

    requestAnimationFrame(stepGPU);
  </script>
</body>
</html>
