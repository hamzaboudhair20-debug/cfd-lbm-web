<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LBM D2Q9 – Simulation CFD</title>
  <style>
    /* --- CSS (Interface & Layout) --- */
    * { box-sizing: border-box; user-select: none; -webkit-user-select: none; }

    body {
      margin: 0; padding: 0;
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: #020617; color: #e2e8f0;
      height: 100vh; width: 100vw;
      display: flex; flex-direction: column;
      overflow: hidden;
    }

    /* Header */
    header {
      height: 50px; padding: 0 20px;
      display: flex; align-items: center; justify-content: space-between;
      background: #0f172a; border-bottom: 1px solid #1e293b;
      flex-shrink: 0;
    }
    header h1 { font-size: 16px; color: #38bdf8; margin: 0; }
    header .badge { font-size: 10px; background: #1e293b; padding: 4px 8px; border-radius: 4px; color: #94a3b8; }

    /* Layout Principal */
    main.layout {
      flex: 1; display: flex; overflow: hidden;
    }

    /* Zone Canvas (Gauche) */
    #sim-container {
      flex: 1; background: #000;
      position: relative;
      display: flex; justify-content: center; align-items: center;
      overflow: hidden;
    }
    canvas {
      display: block;
      image-rendering: pixelated; /* Important pour la netteté */
      box-shadow: 0 0 30px rgba(0,0,0,0.5);
    }

    /* Légende (Overlay) */
    .legend-overlay {
      position: absolute; top: 20px; right: 20px;
      background: rgba(15, 23, 42, 0.8);
      backdrop-filter: blur(4px);
      padding: 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.1);
      display: flex; gap: 10px; align-items: center;
    }
    .colorbar { width: 100px; height: 12px; background: linear-gradient(to right, #0f172a, #3b82f6, #eab308, #ef4444); border-radius: 2px; }
    .legend-text { font-size: 10px; color: #ccc; }

    /* Sidebar (Droite) */
    aside#controls {
      width: 320px; background: #0f172a; border-left: 1px solid #1e293b;
      display: flex; flex-direction: column;
      flex-shrink: 0; z-index: 10;
    }

    .scroll-area { flex: 1; overflow-y: auto; padding: 20px; }

    /* Widgets */
    .section { margin-bottom: 25px; }
    .section h3 { font-size: 12px; text-transform: uppercase; color: #64748b; margin-bottom: 10px; letter-spacing: 1px; }
    
    .control-row { margin-bottom: 15px; }
    .label-row { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 13px; color: #cbd5e1; }
    .val { color: #38bdf8; font-family: monospace; }

    input[type=range] {
      width: 100%; height: 4px; background: #334155; border-radius: 2px;
      outline: none; -webkit-appearance: none; cursor: pointer;
    }
    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none; width: 16px; height: 16px; background: #38bdf8; border-radius: 50%;
      margin-top: 0; box-shadow: 0 0 10px rgba(56, 189, 248, 0.5);
    }

    select {
      width: 100%; padding: 8px; background: #1e293b; color: white; border: 1px solid #334155; border-radius: 6px; outline: none; cursor: pointer;
    }

    /* Boutons */
    .btn-group { display: flex; gap: 10px; margin-top: 10px; }
    button {
      flex: 1; padding: 10px; border: none; border-radius: 6px; font-size: 12px; font-weight: 600; cursor: pointer; transition: 0.2s;
    }
    button.primary { background: #2563eb; color: white; }
    button.primary:hover { background: #1d4ed8; }
    button.secondary { background: #334155; color: #e2e8f0; }
    button.secondary:hover { background: #475569; }

    /* Stats Footer */
    .stats-footer {
      padding: 15px 20px; border-top: 1px solid #1e293b;
      font-size: 11px; color: #64748b; background: #0b1120;
    }
    .stat-item { display: flex; justify-content: space-between; margin-bottom: 4px; }

    /* MODAL DE DEMARRAGE (Le problème des boutons) */
    #startup-modal {
      position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
      background: rgba(2, 6, 23, 0.95);
      z-index: 9999; /* Très haut pour être au dessus de tout */
      display: flex; justify-content: center; align-items: center;
    }
    .modal-box {
      background: #0f172a; padding: 30px; border-radius: 12px; border: 1px solid #334155;
      max-width: 400px; text-align: center; box-shadow: 0 20px 50px rgba(0,0,0,0.5);
    }
    .modal-box h2 { color: #38bdf8; margin-top: 0; }
    .modal-box p { color: #94a3b8; font-size: 14px; line-height: 1.5; margin-bottom: 25px; }
    
  </style>
</head>

<body>

  <div id="startup-modal">
    <div class="modal-box">
      <h2>LBM Flow Simulator</h2>
      <p>
        Simulation de mécanique des fluides (CFD) temps réel.<br>
        Modèle: Lattice Boltzmann D2Q9.<br>
        Profil: Joukowsky Interactif.
      </p>
      <div class="btn-group">
        <button id="btn-start" class="primary">Démarrer la Simulation</button>
      </div>
      <div style="margin-top:10px;">
         <button id="btn-low-res" class="secondary" style="font-size:10px; padding:6px;">Mode Performance (PC Lent)</button>
      </div>
    </div>
  </div>

  <header>
    <h1>Virtual Wind Tunnel</h1>
    <span class="badge">WebGL / JS</span>
  </header>

  <main class="layout">
    <section id="sim-container">
      <canvas id="sim-canvas"></canvas>
      
      <div class="legend-overlay">
        <span class="legend-text">0.0</span>
        <div class="colorbar"></div>
        <span class="legend-text">1.0</span>
      </div>
    </section>

    <aside id="controls">
      <div class="scroll-area">
        
        <div class="section">
          <h3>Visualisation</h3>
          <div class="control-row">
            <select id="viz-mode">
              <option value="curl">Vorticité (Tourbillons)</option>
              <option value="speed">Vitesse (Magnitude)</option>
              <option value="pressure">Pression</option>
            </select>
          </div>
        </div>

        <div class="section">
          <h3>Paramètres Fluide</h3>
          <div class="control-row">
            <div class="label-row">
              <label>Vitesse (Mach)</label>
              <span class="val" id="disp-mach">0.10</span>
            </div>
            <input type="range" id="input-mach" min="0.02" max="0.3" step="0.01" value="0.10">
          </div>
          
          <div class="control-row">
            <div class="label-row">
              <label>Viscosité (Re)</label>
              <span class="val" id="disp-visc">0.65</span>
            </div>
            <input type="range" id="input-visc" min="0.51" max="1.2" step="0.01" value="0.65">
          </div>
        </div>

        <div class="section">
          <h3>Géométrie Aile</h3>
          <div class="control-row">
            <div class="label-row">
              <label>Angle d'Attaque</label>
              <span class="val" id="disp-aoa">15°</span>
            </div>
            <input type="range" id="input-aoa" min="-20" max="45" step="1" value="15">
          </div>

          <div class="control-row">
            <div class="label-row">
              <label>Épaisseur</label>
              <span class="val" id="disp-thick">0.12</span>
            </div>
            <input type="range" id="input-thick" min="0.05" max="0.30" step="0.01" value="0.12">
          </div>
        </div>

        <div class="btn-group">
          <button id="btn-reset" class="secondary">Reset</button>
          <button id="btn-pause" class="primary">Pause</button>
        </div>

      </div>

      <div class="stats-footer">
        <div class="stat-item"><span>FPS</span><span id="stat-fps" style="color:#eee">0</span></div>
        <div class="stat-item"><span>Steps</span><span id="stat-steps">0</span></div>
        <div class="stat-item"><span>Reynolds</span><span id="stat-re" style="color:#38bdf8">~2000</span></div>
      </div>
    </aside>
  </main>

<script>
/**
 * SCRIPT PRINCIPAL LBM
 * Logique des boutons placée EN PREMIER pour garantir le fonctionnement
 */

// --- 1. GESTION DES BOUTONS (PRIORITÉ ABSOLUE) ---
const modal = document.getElementById('startup-modal');
const btnStart = document.getElementById('btn-start');
const btnLowRes = document.getElementById('btn-low-res');

// Démarrage Standard
btnStart.addEventListener('click', function() {
  console.log("Bouton Start cliqué");
  modal.style.display = 'none';
  initSim(); // Lance la sim
  running = true;
  loop();
});

// Démarrage Basse Résolution
btnLowRes.addEventListener('click', function() {
  console.log("Bouton Low Res cliqué");
  modal.style.display = 'none';
  Nx = 200; Ny = 80; // Réduire la grille
  initSim();
  running = true;
  loop();
});

// Autres boutons UI
document.getElementById('btn-pause').addEventListener('click', () => {
  running = !running;
  if(running) loop();
});

document.getElementById('btn-reset').addEventListener('click', () => {
  initSim();
});


// --- 2. CONFIGURATION CANVAS & VARIABLES ---
const canvas = document.getElementById('sim-canvas');
// Utilisation de willReadFrequently pour optimiser les lectures de pixels répétées
const ctx = canvas.getContext('2d', { willReadFrequently: true });

let Nx = 400; // Largeur grille par défaut
let Ny = 160; // Hauteur grille par défaut

// Constantes Lattice Boltzmann D2Q9
const Q = 9;
const w = [4/9, 1/9, 1/9, 1/9, 1/9, 1/36, 1/36, 1/36, 1/36];
const cx = [0, 1, 0, -1, 0, 1, -1, -1, 1];
const cy = [0, 0, 1, 0, -1, 1, 1, -1, -1];
const opp = [0, 3, 4, 1, 2, 7, 8, 5, 6];

// Variables globales (Allouées dans initSim)
let f, fTmp, rho, ux, uy, barrier, vort, imgData, pixels;
let running = false;
let steps = 0;

// Paramètres par défaut
let params = {
  mach: 0.1,
  tau: 0.65,
  aoa: 15,
  thick: 0.12,
  viz: 'curl'
};

// --- 3. FONCTIONS D'INITIALISATION ---

function allocateMemory() {
  // Redimensionne le canvas pour correspondre à la grille physique
  canvas.width = Nx;
  canvas.height = Ny;
  
  const size = Nx * Ny;
  f = new Float32Array(Q * size);
  fTmp = new Float32Array(Q * size);
  rho = new Float32Array(size);
  ux = new Float32Array(size);
  uy = new Float32Array(size);
  barrier = new Uint8Array(size);
  vort = new Float32Array(size);
  
  imgData = ctx.createImageData(Nx, Ny);
  pixels = imgData.data;
}

function createAirfoil() {
  const size = Nx * Ny;
  barrier.fill(0);
  
  // Murs haut et bas
  for(let x=0; x<Nx; x++) {
    barrier[x] = 1;
    barrier[x + (Ny-1)*Nx] = 1;
  }

  // Géométrie Joukowsky Simplifiée (Goutte d'eau rotative)
  const cx_foil = Nx / 3.5;
  const cy_foil = Ny / 2;
  const scale = Ny / 6; // Taille aile
  const rad = Math.PI / 180;
  const ang = params.aoa * rad;
  const thick = params.thick;

  for(let y=0; y<Ny; y++) {
    for(let x=0; x<Nx; x++) {
      // Coordonnées relatives
      let dx = (x - cx_foil) / scale;
      let dy = (y - cy_foil) / scale;

      // Rotation inverse
      let rx = dx * Math.cos(-ang) - dy * Math.sin(-ang);
      let ry = dx * Math.sin(-ang) + dy * Math.cos(-ang);

      // Forme : Cercle déformé
      // Équation implicite approximative d'un profil
      // x = rx, y = ry. 
      // Bord d'attaque arrondi, bord de fuite pointu
      
      // Distance au centre modifiée
      let d = Math.sqrt(rx*rx + ry*ry * (4.0 - 3.0*thick)); 
      
      // Ajout d'une "queue" pour faire l'aile
      if(rx > 0) d += rx * 0.2; // Etire l'arrière
      
      // Cambrure simple
      if(ry > 0) d += ry * 0.1; 

      if(d < 1.0) {
        barrier[x + y*Nx] = 1;
      }
    }
  }
}

function initSim() {
  allocateMemory();
  createAirfoil();
  
  const size = Nx * Ny;
  const u0 = params.mach * 0.577; // Vitesse initiale
  
  for(let i=0; i<size; i++) {
    rho[i] = 1.0;
    ux[i] = barrier[i] ? 0 : u0;
    uy[i] = 0;
    
    // Distribution d'équilibre (fEq)
    const u2 = ux[i]*ux[i] + uy[i]*uy[i];
    for(let k=0; k<Q; k++) {
      const cu = 3*(cx[k]*ux[i] + cy[k]*uy[i]);
      f[k*size+i] = w[k]*rho[i]*(1 + cu + 0.5*cu*cu - 1.5*u2);
    }
  }
  steps = 0;
}

// --- 4. MOTEUR PHYSIQUE (BOUCLE DE CALCUL) ---

function lbmStep() {
  const size = Nx * Ny;
  const uIn = params.mach * 0.577;
  const omega = 1.0 / params.tau;

  // COLLISION (BGK)
  for(let i=0; i<size; i++) {
    if(barrier[i]) continue;

    let r=0, u=0, v=0;
    for(let k=0; k<Q; k++) {
      const val = f[k*size+i];
      r += val;
      u += val*cx[k];
      v += val*cy[k];
    }

    // Conditions Entrée (Gauche)
    const modX = i % Nx;
    if(modX === 0) {
      r = 1.0; u = uIn; v = 0;
    }

    rho[i] = r;
    if(r > 0) { ux[i] = u/r; uy[i] = v/r; }

    const u2 = ux[i]*ux[i] + uy[i]*uy[i];
    
    // Relaxation
    for(let k=0; k<Q; k++) {
      const cu = 3*(cx[k]*ux[i] + cy[k]*uy[i]);
      const fEq = w[k]*r*(1 + cu + 0.5*cu*cu - 1.5*u2);
      fTmp[k*size+i] = f[k*size+i] * (1-omega) + fEq * omega;
    }
  }

  // STREAMING (PROPAGATION)
  for(let y=0; y<Ny; y++) {
    for(let x=0; x<Nx; x++) {
      const i = x + y*Nx;
      
      for(let k=0; k<Q; k++) {
        const nextX = x + cx[k];
        const nextY = y + cy[k];
        
        if(nextX >= 0 && nextX < Nx && nextY >= 0 && nextY < Ny) {
          const nextI = nextX + nextY*Nx;
          
          if(barrier[nextI]) {
             // Rebond sur mur (Bounce-back)
             f[opp[k]*size + i] = fTmp[k*size + i];
          } else {
             // Propagation normale
             f[k*size + nextI] = fTmp[k*size + i];
          }
        }
      }
    }
  }
  steps++;
}

// --- 5. RENDU GRAPHIQUE ---

function render() {
  const size = Nx * Ny;
  // Facteurs de couleur
  const s_vort = 50; 
  const s_speed = 1.5 / params.mach;

  for(let i=0; i<size; i++) {
    const p = i*4; // Index pixel (RGBA)

    if(barrier[i]) {
      // Couleur Obstacle (Gris Sombre)
      pixels[p]=60; pixels[p+1]=60; pixels[p+2]=70; pixels[p+3]=255;
    } else {
      let r=0, g=0, b=0;

      if(params.viz === 'curl') {
        // Calcul vorticité à la volée (Curl)
        // Simplifié : (uy[x+1] - uy[x-1]) - (ux[y+1] - ux[y-1])
        // Ici on fait une approx locale rapide pour l'affichage
        let curlVal = 0;
        // Check boundaries limits manually or skip edges
        if(i > Nx && i < size-Nx) {
           curlVal = (uy[i+1] - uy[i-1]) - (ux[i+Nx] - ux[i-Nx]);
        }
        
        let val = curlVal * s_vort;
        // Diverging (Bleu - Noir - Rouge)
        if(val > 0) { // Rotation + (Rouge/Jaune)
           r = Math.min(255, val*255);
           g = Math.min(255, val*100);
        } else {      // Rotation - (Bleu/Cyan)
           val = -val;
           b = Math.min(255, val*255);
           g = Math.min(255, val*100);
        }
        // Fond légèrement bleuté pour le fluide
        b += 20; 
      } 
      else if(params.viz === 'speed') {
         // Heatmap Vitesse
         const speed = Math.sqrt(ux[i]**2 + uy[i]**2);
         let val = speed * s_speed; // 0..1
         // Turbo map approx
         r = Math.min(255, val * 255);
         g = Math.min(255, val * 200);
         b = 255 - r;
      }
      else {
         // Pression
         const press = (rho[i]-1.0) * 500 + 0.5;
         r = press * 255;
         g = press * 255; 
         b = press * 255;
      }

      pixels[p] = r; pixels[p+1] = g; pixels[p+2] = b; pixels[p+3] = 255;
    }
  }
  ctx.putImageData(imgData, 0, 0);
}

// --- 6. BOUCLE PRINCIPALE & UI ---

let lastTime = 0;
function loop(timestamp) {
  if(!running) return;

  // Limite de temps pour ne pas figer le navigateur
  // On fait plusieurs pas de physique par frame graphique
  for(let i=0; i<4; i++) {
    lbmStep();
  }
  
  render();

  // Stats
  if(timestamp - lastTime > 500) {
    const fps = 1000 / (timestamp - lastTime);
    document.getElementById('stat-fps').innerText = (fps*4).toFixed(0); // *4 car on rafraichit stats ttes les 500ms
    document.getElementById('stat-steps').innerText = steps;
    
    // Reynolds Approx
    const Re = (params.mach * 0.577 * (Ny/6)) / ((params.tau-0.5)/3);
    document.getElementById('stat-re').innerText = Re.toFixed(0);
    
    lastTime = timestamp;
  }

  requestAnimationFrame(loop);
}

// Binding Sliders (Inputs)
document.getElementById('input-mach').oninput = function(e) {
  params.mach = parseFloat(e.target.value);
  document.getElementById('disp-mach').innerText = params.mach;
};
document.getElementById('input-visc').oninput = function(e) {
  params.tau = parseFloat(e.target.value);
  document.getElementById('disp-visc').innerText = params.tau;
};
document.getElementById('input-aoa').oninput = function(e) {
  params.aoa = parseFloat(e.target.value);
  document.getElementById('disp-aoa').innerText = params.aoa + "°";
  createAirfoil(); // Recalcul géométrie immédiat
};
document.getElementById('input-thick').oninput = function(e) {
  params.thick = parseFloat(e.target.value);
  document.getElementById('disp-thick').innerText = params.thick;
  createAirfoil();
};
document.getElementById('viz-mode').onchange = function(e) {
  params.viz = e.target.value;
};

</script>
</body>
</html><!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LBM D2Q9 – Simulation CFD</title>
  <style>
    /* --- CSS (Interface & Layout) --- */
    * { box-sizing: border-box; user-select: none; -webkit-user-select: none; }

    body {
      margin: 0; padding: 0;
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: #020617; color: #e2e8f0;
      height: 100vh; width: 100vw;
      display: flex; flex-direction: column;
      overflow: hidden;
    }

    /* Header */
    header {
      height: 50px; padding: 0 20px;
      display: flex; align-items: center; justify-content: space-between;
      background: #0f172a; border-bottom: 1px solid #1e293b;
      flex-shrink: 0;
    }
    header h1 { font-size: 16px; color: #38bdf8; margin: 0; }
    header .badge { font-size: 10px; background: #1e293b; padding: 4px 8px; border-radius: 4px; color: #94a3b8; }

    /* Layout Principal */
    main.layout {
      flex: 1; display: flex; overflow: hidden;
    }

    /* Zone Canvas (Gauche) */
    #sim-container {
      flex: 1; background: #000;
      position: relative;
      display: flex; justify-content: center; align-items: center;
      overflow: hidden;
    }
    canvas {
      display: block;
      image-rendering: pixelated; /* Important pour la netteté */
      box-shadow: 0 0 30px rgba(0,0,0,0.5);
    }

    /* Légende (Overlay) */
    .legend-overlay {
      position: absolute; top: 20px; right: 20px;
      background: rgba(15, 23, 42, 0.8);
      backdrop-filter: blur(4px);
      padding: 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.1);
      display: flex; gap: 10px; align-items: center;
    }
    .colorbar { width: 100px; height: 12px; background: linear-gradient(to right, #0f172a, #3b82f6, #eab308, #ef4444); border-radius: 2px; }
    .legend-text { font-size: 10px; color: #ccc; }

    /* Sidebar (Droite) */
    aside#controls {
      width: 320px; background: #0f172a; border-left: 1px solid #1e293b;
      display: flex; flex-direction: column;
      flex-shrink: 0; z-index: 10;
    }

    .scroll-area { flex: 1; overflow-y: auto; padding: 20px; }

    /* Widgets */
    .section { margin-bottom: 25px; }
    .section h3 { font-size: 12px; text-transform: uppercase; color: #64748b; margin-bottom: 10px; letter-spacing: 1px; }
    
    .control-row { margin-bottom: 15px; }
    .label-row { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 13px; color: #cbd5e1; }
    .val { color: #38bdf8; font-family: monospace; }

    input[type=range] {
      width: 100%; height: 4px; background: #334155; border-radius: 2px;
      outline: none; -webkit-appearance: none; cursor: pointer;
    }
    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none; width: 16px; height: 16px; background: #38bdf8; border-radius: 50%;
      margin-top: 0; box-shadow: 0 0 10px rgba(56, 189, 248, 0.5);
    }

    select {
      width: 100%; padding: 8px; background: #1e293b; color: white; border: 1px solid #334155; border-radius: 6px; outline: none; cursor: pointer;
    }

    /* Boutons */
    .btn-group { display: flex; gap: 10px; margin-top: 10px; }
    button {
      flex: 1; padding: 10px; border: none; border-radius: 6px; font-size: 12px; font-weight: 600; cursor: pointer; transition: 0.2s;
    }
    button.primary { background: #2563eb; color: white; }
    button.primary:hover { background: #1d4ed8; }
    button.secondary { background: #334155; color: #e2e8f0; }
    button.secondary:hover { background: #475569; }

    /* Stats Footer */
    .stats-footer {
      padding: 15px 20px; border-top: 1px solid #1e293b;
      font-size: 11px; color: #64748b; background: #0b1120;
    }
    .stat-item { display: flex; justify-content: space-between; margin-bottom: 4px; }

    /* MODAL DE DEMARRAGE (Le problème des boutons) */
    #startup-modal {
      position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
      background: rgba(2, 6, 23, 0.95);
      z-index: 9999; /* Très haut pour être au dessus de tout */
      display: flex; justify-content: center; align-items: center;
    }
    .modal-box {
      background: #0f172a; padding: 30px; border-radius: 12px; border: 1px solid #334155;
      max-width: 400px; text-align: center; box-shadow: 0 20px 50px rgba(0,0,0,0.5);
    }
    .modal-box h2 { color: #38bdf8; margin-top: 0; }
    .modal-box p { color: #94a3b8; font-size: 14px; line-height: 1.5; margin-bottom: 25px; }
    
  </style>
</head>

<body>

  <div id="startup-modal">
    <div class="modal-box">
      <h2>LBM Flow Simulator</h2>
      <p>
        Simulation de mécanique des fluides (CFD) temps réel.<br>
        Modèle: Lattice Boltzmann D2Q9.<br>
        Profil: Joukowsky Interactif.
      </p>
      <div class="btn-group">
        <button id="btn-start" class="primary">Démarrer la Simulation</button>
      </div>
      <div style="margin-top:10px;">
         <button id="btn-low-res" class="secondary" style="font-size:10px; padding:6px;">Mode Performance (PC Lent)</button>
      </div>
    </div>
  </div>

  <header>
    <h1>Virtual Wind Tunnel</h1>
    <span class="badge">WebGL / JS</span>
  </header>

  <main class="layout">
    <section id="sim-container">
      <canvas id="sim-canvas"></canvas>
      
      <div class="legend-overlay">
        <span class="legend-text">0.0</span>
        <div class="colorbar"></div>
        <span class="legend-text">1.0</span>
      </div>
    </section>

    <aside id="controls">
      <div class="scroll-area">
        
        <div class="section">
          <h3>Visualisation</h3>
          <div class="control-row">
            <select id="viz-mode">
              <option value="curl">Vorticité (Tourbillons)</option>
              <option value="speed">Vitesse (Magnitude)</option>
              <option value="pressure">Pression</option>
            </select>
          </div>
        </div>

        <div class="section">
          <h3>Paramètres Fluide</h3>
          <div class="control-row">
            <div class="label-row">
              <label>Vitesse (Mach)</label>
              <span class="val" id="disp-mach">0.10</span>
            </div>
            <input type="range" id="input-mach" min="0.02" max="0.3" step="0.01" value="0.10">
          </div>
          
          <div class="control-row">
            <div class="label-row">
              <label>Viscosité (Re)</label>
              <span class="val" id="disp-visc">0.65</span>
            </div>
            <input type="range" id="input-visc" min="0.51" max="1.2" step="0.01" value="0.65">
          </div>
        </div>

        <div class="section">
          <h3>Géométrie Aile</h3>
          <div class="control-row">
            <div class="label-row">
              <label>Angle d'Attaque</label>
              <span class="val" id="disp-aoa">15°</span>
            </div>
            <input type="range" id="input-aoa" min="-20" max="45" step="1" value="15">
          </div>

          <div class="control-row">
            <div class="label-row">
              <label>Épaisseur</label>
              <span class="val" id="disp-thick">0.12</span>
            </div>
            <input type="range" id="input-thick" min="0.05" max="0.30" step="0.01" value="0.12">
          </div>
        </div>

        <div class="btn-group">
          <button id="btn-reset" class="secondary">Reset</button>
          <button id="btn-pause" class="primary">Pause</button>
        </div>

      </div>

      <div class="stats-footer">
        <div class="stat-item"><span>FPS</span><span id="stat-fps" style="color:#eee">0</span></div>
        <div class="stat-item"><span>Steps</span><span id="stat-steps">0</span></div>
        <div class="stat-item"><span>Reynolds</span><span id="stat-re" style="color:#38bdf8">~2000</span></div>
      </div>
    </aside>
  </main>

<script>
/**
 * SCRIPT PRINCIPAL LBM
 * Logique des boutons placée EN PREMIER pour garantir le fonctionnement
 */

// --- 1. GESTION DES BOUTONS (PRIORITÉ ABSOLUE) ---
const modal = document.getElementById('startup-modal');
const btnStart = document.getElementById('btn-start');
const btnLowRes = document.getElementById('btn-low-res');

// Démarrage Standard
btnStart.addEventListener('click', function() {
  console.log("Bouton Start cliqué");
  modal.style.display = 'none';
  initSim(); // Lance la sim
  running = true;
  loop();
});

// Démarrage Basse Résolution
btnLowRes.addEventListener('click', function() {
  console.log("Bouton Low Res cliqué");
  modal.style.display = 'none';
  Nx = 200; Ny = 80; // Réduire la grille
  initSim();
  running = true;
  loop();
});

// Autres boutons UI
document.getElementById('btn-pause').addEventListener('click', () => {
  running = !running;
  if(running) loop();
});

document.getElementById('btn-reset').addEventListener('click', () => {
  initSim();
});


// --- 2. CONFIGURATION CANVAS & VARIABLES ---
const canvas = document.getElementById('sim-canvas');
// Utilisation de willReadFrequently pour optimiser les lectures de pixels répétées
const ctx = canvas.getContext('2d', { willReadFrequently: true });

let Nx = 400; // Largeur grille par défaut
let Ny = 160; // Hauteur grille par défaut

// Constantes Lattice Boltzmann D2Q9
const Q = 9;
const w = [4/9, 1/9, 1/9, 1/9, 1/9, 1/36, 1/36, 1/36, 1/36];
const cx = [0, 1, 0, -1, 0, 1, -1, -1, 1];
const cy = [0, 0, 1, 0, -1, 1, 1, -1, -1];
const opp = [0, 3, 4, 1, 2, 7, 8, 5, 6];

// Variables globales (Allouées dans initSim)
let f, fTmp, rho, ux, uy, barrier, vort, imgData, pixels;
let running = false;
let steps = 0;

// Paramètres par défaut
let params = {
  mach: 0.1,
  tau: 0.65,
  aoa: 15,
  thick: 0.12,
  viz: 'curl'
};

// --- 3. FONCTIONS D'INITIALISATION ---

function allocateMemory() {
  // Redimensionne le canvas pour correspondre à la grille physique
  canvas.width = Nx;
  canvas.height = Ny;
  
  const size = Nx * Ny;
  f = new Float32Array(Q * size);
  fTmp = new Float32Array(Q * size);
  rho = new Float32Array(size);
  ux = new Float32Array(size);
  uy = new Float32Array(size);
  barrier = new Uint8Array(size);
  vort = new Float32Array(size);
  
  imgData = ctx.createImageData(Nx, Ny);
  pixels = imgData.data;
}

function createAirfoil() {
  const size = Nx * Ny;
  barrier.fill(0);
  
  // Murs haut et bas
  for(let x=0; x<Nx; x++) {
    barrier[x] = 1;
    barrier[x + (Ny-1)*Nx] = 1;
  }

  // Géométrie Joukowsky Simplifiée (Goutte d'eau rotative)
  const cx_foil = Nx / 3.5;
  const cy_foil = Ny / 2;
  const scale = Ny / 6; // Taille aile
  const rad = Math.PI / 180;
  const ang = params.aoa * rad;
  const thick = params.thick;

  for(let y=0; y<Ny; y++) {
    for(let x=0; x<Nx; x++) {
      // Coordonnées relatives
      let dx = (x - cx_foil) / scale;
      let dy = (y - cy_foil) / scale;

      // Rotation inverse
      let rx = dx * Math.cos(-ang) - dy * Math.sin(-ang);
      let ry = dx * Math.sin(-ang) + dy * Math.cos(-ang);

      // Forme : Cercle déformé
      // Équation implicite approximative d'un profil
      // x = rx, y = ry. 
      // Bord d'attaque arrondi, bord de fuite pointu
      
      // Distance au centre modifiée
      let d = Math.sqrt(rx*rx + ry*ry * (4.0 - 3.0*thick)); 
      
      // Ajout d'une "queue" pour faire l'aile
      if(rx > 0) d += rx * 0.2; // Etire l'arrière
      
      // Cambrure simple
      if(ry > 0) d += ry * 0.1; 

      if(d < 1.0) {
        barrier[x + y*Nx] = 1;
      }
    }
  }
}

function initSim() {
  allocateMemory();
  createAirfoil();
  
  const size = Nx * Ny;
  const u0 = params.mach * 0.577; // Vitesse initiale
  
  for(let i=0; i<size; i++) {
    rho[i] = 1.0;
    ux[i] = barrier[i] ? 0 : u0;
    uy[i] = 0;
    
    // Distribution d'équilibre (fEq)
    const u2 = ux[i]*ux[i] + uy[i]*uy[i];
    for(let k=0; k<Q; k++) {
      const cu = 3*(cx[k]*ux[i] + cy[k]*uy[i]);
      f[k*size+i] = w[k]*rho[i]*(1 + cu + 0.5*cu*cu - 1.5*u2);
    }
  }
  steps = 0;
}

// --- 4. MOTEUR PHYSIQUE (BOUCLE DE CALCUL) ---

function lbmStep() {
  const size = Nx * Ny;
  const uIn = params.mach * 0.577;
  const omega = 1.0 / params.tau;

  // COLLISION (BGK)
  for(let i=0; i<size; i++) {
    if(barrier[i]) continue;

    let r=0, u=0, v=0;
    for(let k=0; k<Q; k++) {
      const val = f[k*size+i];
      r += val;
      u += val*cx[k];
      v += val*cy[k];
    }

    // Conditions Entrée (Gauche)
    const modX = i % Nx;
    if(modX === 0) {
      r = 1.0; u = uIn; v = 0;
    }

    rho[i] = r;
    if(r > 0) { ux[i] = u/r; uy[i] = v/r; }

    const u2 = ux[i]*ux[i] + uy[i]*uy[i];
    
    // Relaxation
    for(let k=0; k<Q; k++) {
      const cu = 3*(cx[k]*ux[i] + cy[k]*uy[i]);
      const fEq = w[k]*r*(1 + cu + 0.5*cu*cu - 1.5*u2);
      fTmp[k*size+i] = f[k*size+i] * (1-omega) + fEq * omega;
    }
  }

  // STREAMING (PROPAGATION)
  for(let y=0; y<Ny; y++) {
    for(let x=0; x<Nx; x++) {
      const i = x + y*Nx;
      
      for(let k=0; k<Q; k++) {
        const nextX = x + cx[k];
        const nextY = y + cy[k];
        
        if(nextX >= 0 && nextX < Nx && nextY >= 0 && nextY < Ny) {
          const nextI = nextX + nextY*Nx;
          
          if(barrier[nextI]) {
             // Rebond sur mur (Bounce-back)
             f[opp[k]*size + i] = fTmp[k*size + i];
          } else {
             // Propagation normale
             f[k*size + nextI] = fTmp[k*size + i];
          }
        }
      }
    }
  }
  steps++;
}

// --- 5. RENDU GRAPHIQUE ---

function render() {
  const size = Nx * Ny;
  // Facteurs de couleur
  const s_vort = 50; 
  const s_speed = 1.5 / params.mach;

  for(let i=0; i<size; i++) {
    const p = i*4; // Index pixel (RGBA)

    if(barrier[i]) {
      // Couleur Obstacle (Gris Sombre)
      pixels[p]=60; pixels[p+1]=60; pixels[p+2]=70; pixels[p+3]=255;
    } else {
      let r=0, g=0, b=0;

      if(params.viz === 'curl') {
        // Calcul vorticité à la volée (Curl)
        // Simplifié : (uy[x+1] - uy[x-1]) - (ux[y+1] - ux[y-1])
        // Ici on fait une approx locale rapide pour l'affichage
        let curlVal = 0;
        // Check boundaries limits manually or skip edges
        if(i > Nx && i < size-Nx) {
           curlVal = (uy[i+1] - uy[i-1]) - (ux[i+Nx] - ux[i-Nx]);
        }
        
        let val = curlVal * s_vort;
        // Diverging (Bleu - Noir - Rouge)
        if(val > 0) { // Rotation + (Rouge/Jaune)
           r = Math.min(255, val*255);
           g = Math.min(255, val*100);
        } else {      // Rotation - (Bleu/Cyan)
           val = -val;
           b = Math.min(255, val*255);
           g = Math.min(255, val*100);
        }
        // Fond légèrement bleuté pour le fluide
        b += 20; 
      } 
      else if(params.viz === 'speed') {
         // Heatmap Vitesse
         const speed = Math.sqrt(ux[i]**2 + uy[i]**2);
         let val = speed * s_speed; // 0..1
         // Turbo map approx
         r = Math.min(255, val * 255);
         g = Math.min(255, val * 200);
         b = 255 - r;
      }
      else {
         // Pression
         const press = (rho[i]-1.0) * 500 + 0.5;
         r = press * 255;
         g = press * 255; 
         b = press * 255;
      }

      pixels[p] = r; pixels[p+1] = g; pixels[p+2] = b; pixels[p+3] = 255;
    }
  }
  ctx.putImageData(imgData, 0, 0);
}

// --- 6. BOUCLE PRINCIPALE & UI ---

let lastTime = 0;
function loop(timestamp) {
  if(!running) return;

  // Limite de temps pour ne pas figer le navigateur
  // On fait plusieurs pas de physique par frame graphique
  for(let i=0; i<4; i++) {
    lbmStep();
  }
  
  render();

  // Stats
  if(timestamp - lastTime > 500) {
    const fps = 1000 / (timestamp - lastTime);
    document.getElementById('stat-fps').innerText = (fps*4).toFixed(0); // *4 car on rafraichit stats ttes les 500ms
    document.getElementById('stat-steps').innerText = steps;
    
    // Reynolds Approx
    const Re = (params.mach * 0.577 * (Ny/6)) / ((params.tau-0.5)/3);
    document.getElementById('stat-re').innerText = Re.toFixed(0);
    
    lastTime = timestamp;
  }

  requestAnimationFrame(loop);
}

// Binding Sliders (Inputs)
document.getElementById('input-mach').oninput = function(e) {
  params.mach = parseFloat(e.target.value);
  document.getElementById('disp-mach').innerText = params.mach;
};
document.getElementById('input-visc').oninput = function(e) {
  params.tau = parseFloat(e.target.value);
  document.getElementById('disp-visc').innerText = params.tau;
};
document.getElementById('input-aoa').oninput = function(e) {
  params.aoa = parseFloat(e.target.value);
  document.getElementById('disp-aoa').innerText = params.aoa + "°";
  createAirfoil(); // Recalcul géométrie immédiat
};
document.getElementById('input-thick').oninput = function(e) {
  params.thick = parseFloat(e.target.value);
  document.getElementById('disp-thick').innerText = params.thick;
  createAirfoil();
};
document.getElementById('viz-mode').onchange = function(e) {
  params.viz = e.target.value;
};

</script>
</body>
</html>
