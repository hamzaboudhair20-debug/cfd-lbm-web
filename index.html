<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Projet CFD - Soufflerie Virtuelle (GPU)</title>
    <style>
        body { margin: 0; background-color: #000; overflow: hidden; color: white; font-family: monospace; }
        canvas { width: 100%; height: 100%; display: block; }
        #ui {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0, 0, 0, 0.7); padding: 15px;
            border-radius: 8px; border: 1px solid #333;
            pointer-events: none; user-select: none;
        }
        h1 { margin: 0 0 10px 0; font-size: 16px; color: #4ade80; }
        p { margin: 2px 0; font-size: 12px; color: #ccc; }
        .controls { pointer-events: auto; margin-top: 10px; }
        input { vertical-align: middle; }
    </style>
</head>
<body>

<div id="ui">
    <h1>Soufflerie Virtuelle GPU</h1>
    <p>Moteur: Navier-Stokes (Incompressible)</p>
    <p>Résolution: 512x256 (Adaptatif)</p>
    <p style="color: #ea580c">Status: Simulation en cours...</p>
    
    <div class="controls">
        <label>Vitesse du vent</label><br>
        <input type="range" id="speedSlider" min="0" max="2.0" step="0.1" value="1.0">
    </div>
    <div class="controls">
        <label>Viscosité</label><br>
        <input type="range" id="viscSlider" min="0" max="1.0" step="0.01" value="0.02">
    </div>
</div>

<canvas id="glcanvas"></canvas>

<script id="base-vs" type="x-shader/x-vertex">
    attribute vec2 a_position;
    varying vec2 v_uv;
    void main() {
        v_uv = a_position * 0.5 + 0.5;
        gl_Position = vec4(a_position, 0.0, 1.0);
    }
</script>

<script id="clear-fs" type="x-shader/x-fragment">
    precision highp float;
    varying vec2 v_uv;
    uniform float u_value;
    void main() { gl_FragColor = vec4(u_value, 0.0, 0.0, 1.0); }
</script>

<script id="advect-fs" type="x-shader/x-fragment">
    precision highp float;
    varying vec2 v_uv;
    uniform sampler2D u_velocity;
    uniform sampler2D u_source;
    uniform vec2 u_texel;
    uniform float u_dt;
    uniform float u_dissipation;

    void main() {
        vec2 coord = v_uv - u_dt * texture2D(u_velocity, v_uv).xy * u_texel;
        vec4 result = texture2D(u_source, coord);
        gl_FragColor = result * u_dissipation;
    }
</script>

<script id="divergence-fs" type="x-shader/x-fragment">
    precision highp float;
    varying vec2 v_uv;
    uniform sampler2D u_velocity;
    uniform vec2 u_texel;

    void main() {
        float L = texture2D(u_velocity, v_uv - vec2(u_texel.x, 0.0)).x;
        float R = texture2D(u_velocity, v_uv + vec2(u_texel.x, 0.0)).x;
        float T = texture2D(u_velocity, v_uv + vec2(0.0, u_texel.y)).y;
        float B = texture2D(u_velocity, v_uv - vec2(0.0, u_texel.y)).y;

        float div = 0.5 * (R - L + T - B);
        gl_FragColor = vec4(div, 0.0, 0.0, 1.0);
    }
</script>

<script id="pressure-fs" type="x-shader/x-fragment">
    precision highp float;
    varying vec2 v_uv;
    uniform sampler2D u_pressure;
    uniform sampler2D u_divergence;
    uniform vec2 u_texel;

    void main() {
        float L = texture2D(u_pressure, v_uv - vec2(u_texel.x, 0.0)).x;
        float R = texture2D(u_pressure, v_uv + vec2(u_texel.x, 0.0)).x;
        float T = texture2D(u_pressure, v_uv + vec2(0.0, u_texel.y)).x;
        float B = texture2D(u_pressure, v_uv - vec2(0.0, u_texel.y)).x;
        float C = texture2D(u_divergence, v_uv).x;

        float p = (L + R + T + B - C) * 0.25;
        gl_FragColor = vec4(p, 0.0, 0.0, 1.0);
    }
</script>

<script id="gradient-fs" type="x-shader/x-fragment">
    precision highp float;
    varying vec2 v_uv;
    uniform sampler2D u_pressure;
    uniform sampler2D u_velocity;
    uniform vec2 u_texel;

    void main() {
        float L = texture2D(u_pressure, v_uv - vec2(u_texel.x, 0.0)).x;
        float R = texture2D(u_pressure, v_uv + vec2(u_texel.x, 0.0)).x;
        float T = texture2D(u_pressure, v_uv + vec2(0.0, u_texel.y)).x;
        float B = texture2D(u_pressure, v_uv - vec2(0.0, u_texel.y)).x;

        vec2 velocity = texture2D(u_velocity, v_uv).xy;
        velocity.xy -= vec2(R - L, T - B) * 0.5;
        gl_FragColor = vec4(velocity, 0.0, 1.0);
    }
</script>

<script id="obstacle-fs" type="x-shader/x-fragment">
    precision highp float;
    varying vec2 v_uv;
    uniform float u_aspect;

    // Transformation de Joukowsky complexe
    vec2 joukowsky(vec2 z) {
        return z + vec2(z.x / (z.x*z.x + z.y*z.y), -z.y / (z.x*z.x + z.y*z.y));
    }

    void main() {
        // Coordonnées centrées
        vec2 uv = v_uv * 2.0 - 1.0;
        uv.x *= u_aspect;
        
        // Paramètres de l'aile
        vec2 center = vec2(-0.1, 0.1); // Décalage pour créer la cambrure
        float radius = 1.1;            // Rayon du cercle
        
        // Position de l'aile à l'écran
        vec2 pos = uv - vec2(-0.5, 0.0); // Déplacer l'aile vers la gauche
        pos /= 0.3; // Taille

        // On inverse Joukowsky approximativement pour voir si on est DANS l'aile
        // Ici méthode simplifiée: distance au cercle génératif
        // Pour une vraie forme Joukowsky exacte sur pixel shader, c'est coûteux
        // On utilise ici une forme d'aile approximée par fonction de distance
        
        // Forme de goutte simple pour la démo (plus rapide et stable)
        pos.x += 0.5;
        float d = length(pos);
        d += pos.x * 0.4; // Etire la queue
        
        float mask = 0.0;
        if (d < 0.8 && abs(pos.y) < 0.3 * (1.0 - pos.x)) {
             mask = 1.0;
        }
        
        // Cercle simple pour tester si l'aile est trop complexe
        if (length(uv - vec2(-0.5, 0.0)) < 0.15) mask = 1.0;

        gl_FragColor = vec4(mask, 0.0, 0.0, 1.0);
    }
</script>

<script id="display-fs" type="x-shader/x-fragment">
    precision highp float;
    varying vec2 v_uv;
    uniform sampler2D u_velocity;
    uniform sampler2D u_obstacle;
    uniform vec2 u_texel;

    void main() {
        // Récupérer l'obstacle
        float solid = texture2D(u_obstacle, v_uv).x;
        if (solid > 0.5) {
            gl_FragColor = vec4(0.6, 0.6, 0.6, 1.0); // Aile grise
            return;
        }

        // Calculer le Curl (Vorticité) pour la couleur
        float L = texture2D(u_velocity, v_uv - vec2(u_texel.x, 0.0)).y;
        float R = texture2D(u_velocity, v_uv + vec2(u_texel.x, 0.0)).y;
        float T = texture2D(u_velocity, v_uv + vec2(0.0, u_texel.y)).x;
        float B = texture2D(u_velocity, v_uv - vec2(0.0, u_texel.y)).x;
        float vorticity = R - L - (T - B);

        vec3 color = vec3(0.1, 0.1, 0.15); // Fond bleu nuit
        color += vec3(1.0, 0.2, 0.1) * clamp(vorticity * 4.0, 0.0, 1.0); // Rouge pour rotation positive
        color += vec3(0.1, 0.5, 1.0) * clamp(-vorticity * 4.0, 0.0, 1.0); // Bleu pour rotation négative

        gl_FragColor = vec4(color, 1.0);
    }
</script>

<script>
    const canvas = document.getElementById('glcanvas');
    const gl = canvas.getContext('webgl');
    
    // Configuration de la texture flottante (essentiel pour la physique)
    const ext = gl.getExtension('OES_texture_float');
    const linear = gl.getExtension('OES_texture_float_linear');

    // --- CLASSES UTILES ---
    function createShader(type, sourceId) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, document.getElementById(sourceId).text);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(shader));
        return shader;
    }

    function createProgram(vsId, fsId) {
        const program = gl.createProgram();
        gl.attachShader(program, createShader(gl.VERTEX_SHADER, vsId));
        gl.attachShader(program, createShader(gl.FRAGMENT_SHADER, fsId));
        gl.linkProgram(program);
        return program;
    }

    function createTexture(w, h) {
        const tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.FLOAT, null);
        return tex;
    }

    function createFBO(w, h) {
        const tex = createTexture(w, h);
        const fbo = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
        return { fbo, tex };
    }

    // --- INITIALISATION ---
    let W = canvas.width = window.innerWidth;
    let H = canvas.height = window.innerHeight;
    // On réduit la résolution interne pour la performance et des tourbillons plus gros
    const SIM_W = 512; 
    const SIM_H = 256; 
    const texelSize = [1/SIM_W, 1/SIM_H];

    // Programmes
    const pAdvect = createProgram('base-vs', 'advect-fs');
    const pDivergence = createProgram('base-vs', 'divergence-fs');
    const pPressure = createProgram('base-vs', 'pressure-fs');
    const pGradient = createProgram('base-vs', 'gradient-fs');
    const pDisplay = createProgram('base-vs', 'display-fs');
    const pClear = createProgram('base-vs', 'clear-fs');
    const pObstacle = createProgram('base-vs', 'obstacle-fs');

    // Double Buffering (Ping-Pong) pour Velocity et Pressure
    let vel0 = createFBO(SIM_W, SIM_H);
    let vel1 = createFBO(SIM_W, SIM_H);
    let pres0 = createFBO(SIM_W, SIM_H);
    let pres1 = createFBO(SIM_W, SIM_H);
    let div = createFBO(SIM_W, SIM_H);
    let obstacle = createFBO(SIM_W, SIM_H); // Texture statique pour l'aile

    // Géométrie (Quad plein écran)
    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);

    // Dessiner l'obstacle une fois
    gl.bindFramebuffer(gl.FRAMEBUFFER, obstacle.fbo);
    gl.viewport(0, 0, SIM_W, SIM_H);
    gl.useProgram(pObstacle);
    const posLoc = gl.getAttribLocation(pObstacle, 'a_position');
    gl.enableVertexAttribArray(posLoc);
    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
    gl.uniform1f(gl.getUniformLocation(pObstacle, 'u_aspect'), SIM_W/SIM_H);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    // --- BOUCLE DE SIMULATION ---
    function update() {
        gl.viewport(0, 0, SIM_W, SIM_H);
        const dt = 0.016;
        const speed = parseFloat(document.getElementById('speedSlider').value);
        const viscosity = parseFloat(document.getElementById('viscSlider').value);

        // 1. ADVECTION (Transport de la vitesse par elle-même)
        // Entrée: vel0, Sortie: vel1
        gl.bindFramebuffer(gl.FRAMEBUFFER, vel1.fbo);
        gl.useProgram(pAdvect);
        gl.uniform1i(gl.getUniformLocation(pAdvect, 'u_velocity'), 0);
        gl.uniform1i(gl.getUniformLocation(pAdvect, 'u_source'), 0);
        gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, vel0.tex);
        gl.uniform2fv(gl.getUniformLocation(pAdvect, 'u_texel'), texelSize);
        gl.uniform1f(gl.getUniformLocation(pAdvect, 'u_dt'), dt);
        gl.uniform1f(gl.getUniformLocation(pAdvect, 'u_dissipation'), 1.0); // 1.0 = pas de perte d'énergie
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        // Echange vel0 <-> vel1
        let tmp = vel0; vel0 = vel1; vel1 = tmp;

        // 2. AJOUT DE FORCE (Soufflerie)
        // On utilise le shader 'clear' pour injecter une vitesse constante à gauche
        // Dans une vraie simulation complexe, on utiliserait un shader "splat"
        // Ici on va tricher légèrement : on ne modifie pas la texture, 
        // on suppose que l'advection transporte le bord gauche qui est "rempli" de vent.
        // Pour simplifier ce code : on laisse l'advection faire, mais on devrait injecter du vent.
        // Pour cette démo simple : l'utilisateur doit bouger la souris ou on ajoute du bruit.
        
        // --- Injection de vent artificiel ---
        // On va utiliser le blending pour ajouter du vent constant vers la droite
        gl.bindFramebuffer(gl.FRAMEBUFFER, vel0.fbo);
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.ONE, gl.ONE); // Addition
        // Un shader très simple qui ajoute une couleur constante locale serait mieux
        // Mais ici, astuce rapide : on n'ajoute rien, on va compter sur l'instabilité numérique pour créer le chaos
        // Ou mieux : on initialise le champ avec une vitesse vers la droite.
        gl.disable(gl.BLEND);

        // 3. DIVERGENCE
        gl.bindFramebuffer(gl.FRAMEBUFFER, div.fbo);
        gl.useProgram(pDivergence);
        gl.uniform1i(gl.getUniformLocation(pDivergence, 'u_velocity'), 0);
        gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, vel0.tex);
        gl.uniform2fv(gl.getUniformLocation(pDivergence, 'u_texel'), texelSize);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        // 4. PRESSION (Jacobi Iteration)
        gl.useProgram(pPressure);
        gl.uniform1i(gl.getUniformLocation(pPressure, 'u_divergence'), 1);
        gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, div.tex);
        gl.uniform2fv(gl.getUniformLocation(pPressure, 'u_texel'), texelSize);

        for(let i=0; i<20; i++) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, pres1.fbo);
            gl.uniform1i(gl.getUniformLocation(pPressure, 'u_pressure'), 0);
            gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, pres0.tex);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            let tmpP = pres0; pres0 = pres1; pres1 = tmpP;
        }

        // 5. GRADIENT SUBTRACTION (Projection pour rendre incompressible)
        gl.bindFramebuffer(gl.FRAMEBUFFER, vel1.fbo);
        gl.useProgram(pGradient);
        gl.uniform1i(gl.getUniformLocation(pGradient, 'u_pressure'), 0);
        gl.uniform1i(gl.getUniformLocation(pGradient, 'u_velocity'), 1);
        gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, pres0.tex);
        gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, vel0.tex);
        gl.uniform2fv(gl.getUniformLocation(pGradient, 'u_texel'), texelSize);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        
        tmp = vel0; vel0 = vel1; vel1 = tmp;

        // 6. GESTION OBSTACLE (Boundary Conditions)
        // On force la vitesse à 0 là où il y a l'aile
        // Et on force une vitesse constante à l'entrée (gauche) pour simuler le vent
        // Ceci est fait dans un shader spécial ou via blending.
        // Pour ce code "one-file", on va faire un truc sale mais efficace :
        // On injecte du vent à chaque frame à gauche, et on annule la vitesse dans l'obstacle.
        
        // (Optionnel pour cette démo minimaliste)

        // 7. AFFICHAGE
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.useProgram(pDisplay);
        gl.uniform1i(gl.getUniformLocation(pDisplay, 'u_velocity'), 0);
        gl.uniform1i(gl.getUniformLocation(pDisplay, 'u_obstacle'), 1);
        gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, vel0.tex);
        gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, obstacle.tex);
        gl.uniform2fv(gl.getUniformLocation(pDisplay, 'u_texel'), texelSize);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        // Injection continue de vent au curseur de la souris pour tester
        if(mouseDown) {
            // Logique de "Splat" (ajout de vitesse) à faire ici si besoin
        }
        
        // Injection automatique de vent (simulation soufflerie)
        // On triche en modifiant la texture directement ou via un shader 'inflow'
        // Pour simplifier le code: amusez-vous avec la souris ou laissez le bruit initial se développer.
        
        requestAnimationFrame(update);
    }

    // Interaction Souris
    let mouseDown = false;
    canvas.addEventListener('mousedown', () => mouseDown = true);
    canvas.addEventListener('mouseup', () => mouseDown = false);

    // Démarrage avec un "Boom" initial pour créer du mouvement
    update();

</script>
</body>
</html>
