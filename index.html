<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LBM D2Q9 ‚Äì Profil de Joukowsky Pro</title>
  <style>
    /* --- THEME PROFESSIONNEL (Dark Engineering) --- */
    :root {
      --bg-app: #0b1120;       /* Fond tr√®s sombre */
      --bg-panel: #151d30;     /* Fond panneaux */
      --accent: #38bdf8;       /* Bleu cyan pro */
      --accent-hover: #0ea5e9;
      --text-main: #f1f5f9;
      --text-dim: #94a3b8;
      --border: #334155;
      --input-bg: #1e293b;
    }

    * { box-sizing: border-box; user-select: none; }

    body {
      margin: 0; padding: 0;
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      background: var(--bg-app); color: var(--text-main);
      height: 100vh; display: flex; flex-direction: column;
      overflow: hidden;
    }

    /* --- HEADER --- */
    header {
      height: 50px; padding: 0 24px;
      display: flex; align-items: center; justify-content: space-between;
      background: var(--bg-panel); border-bottom: 1px solid var(--border);
      box-shadow: 0 4px 10px rgba(0,0,0,0.2); z-index: 20;
    }
    header h1 {
      font-size: 16px; font-weight: 600; letter-spacing: 0.5px; margin: 0;
      background: linear-gradient(90deg, #38bdf8, #818cf8); -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    }
    .badge {
      font-size: 10px; font-family: monospace; color: var(--accent);
      background: rgba(56, 189, 248, 0.1); padding: 4px 8px; border-radius: 4px; border: 1px solid rgba(56, 189, 248, 0.2);
    }

    /* --- LAYOUT --- */
    main.layout { flex: 1; display: flex; overflow: hidden; }

    /* CANVAS AREA */
    #sim-container {
      flex: 1; background: #000; position: relative;
      display: flex; justify-content: center; align-items: center;
      overflow: hidden;
    }
    canvas {
      display: block; image-rendering: pixelated;
      box-shadow: 0 0 40px rgba(0,0,0,0.6);
      max-width: 100%; max-height: 100%;
    }

    /* OVERLAYS CANVAS */
    .overlay {
      position: absolute; background: rgba(15, 23, 42, 0.9); backdrop-filter: blur(4px);
      border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; padding: 12px;
      pointer-events: none;
    }
    /* L√©gende couleur */
    .legend-panel { top: 20px; right: 20px; display: flex; flex-direction: column; align-items: center; gap: 5px; }
    .colorbar { width: 12px; height: 140px; background: linear-gradient(to top, #0f172a, #3b82f6, #facc15, #ef4444); border-radius: 6px; }
    .legend-val { font-size: 10px; color: var(--text-dim); font-family: monospace; }

    /* Stats Performance */
    .stats-panel { bottom: 20px; left: 20px; display: flex; gap: 15px; font-size: 11px; color: var(--text-dim); font-family: monospace; }
    .stats-panel span { color: var(--text-main); font-weight: bold; }

    /* Controles Canvas (Haut) */
    .canvas-controls {
      position: absolute; top: 20px; left: 20px;
      display: flex; gap: 10px; align-items: center;
      pointer-events: auto; /* Active les clics */
    }
    .canvas-controls select { background: rgba(15, 23, 42, 0.9); border: 1px solid var(--border); }
    .canvas-controls button { width: auto; padding: 6px 12px; margin: 0; }

    /* --- SIDEBAR --- */
    aside#controls {
      width: 340px; background: var(--bg-panel); border-left: 1px solid var(--border);
      display: flex; flex-direction: column; z-index: 15;
    }
    .scroll-area { flex: 1; overflow-y: auto; padding: 25px; }
    .scroll-area::-webkit-scrollbar { width: 5px; }
    .scroll-area::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

    .section { margin-bottom: 30px; }
    .section h3 {
      font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: var(--accent);
      margin: 0 0 15px 0; font-weight: 700; border-bottom: 1px solid var(--border); padding-bottom: 6px;
    }

    /* WIDGETS */
    .control { margin-bottom: 18px; }
    .label-row { display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 12px; color: var(--text-dim); font-weight: 500; }
    .val-display { color: var(--text-main); font-family: monospace; background: rgba(255,255,255,0.05); padding: 2px 6px; border-radius: 4px; }

    input[type="range"] {
      width: 100%; height: 4px; background: var(--input-bg); border-radius: 2px;
      outline: none; -webkit-appearance: none; cursor: pointer; display: block;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none; appearance: none;
      width: 16px; height: 16px; border-radius: 50%;
      background: var(--text-main); border: 2px solid var(--accent);
      box-shadow: 0 0 10px rgba(56, 189, 248, 0.4); transition: transform 0.1s;
      margin-top: -6px; /* Centrage vertical */
    }
    input[type="range"]::-webkit-slider-runnable-track {
      height: 4px; background: var(--input-bg); border-radius: 2px;
    }
    input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.2); }

    /* INDICATEUR VISUEL SOUS SLIDER */
    .slider-wrapper { position: relative; height: 4px; margin-top: 5px; }
    .slider-fill {
      position: absolute; top: 0; left: 0; height: 100%; background: var(--accent);
      border-radius: 2px; pointer-events: none;
    }

    select {
      width: 100%; padding: 8px; background: var(--input-bg); color: white;
      border: 1px solid var(--border); border-radius: 6px; outline: none; cursor: pointer;
    }

    /* DATA CARDS */
    .results-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; background: var(--input-bg); padding: 10px; border-radius: 8px; border: 1px solid var(--border); }
    .res-item { display: flex; flex-direction: column; }
    .res-lbl { font-size: 10px; color: var(--text-dim); }
    .res-val { font-size: 13px; color: var(--text-main); font-weight: 600; font-family: monospace; }

    .info-text { margin-top: 10px; font-size: 10px; color: var(--text-dim); line-height: 1.4; font-style: italic; }

    /* BOUTONS */
    .footer-actions {
      padding: 20px; background: var(--bg-panel); border-top: 1px solid var(--border);
      display: flex; gap: 10px;
    }
    button {
      flex: 1; padding: 12px; border: none; border-radius: 6px;
      font-size: 12px; font-weight: 600; cursor: pointer; transition: all 0.2s;
    }
    button.primary { background: var(--accent); color: #0f172a; }
    button.primary:hover { background: var(--accent-hover); box-shadow: 0 0 15px rgba(56, 189, 248, 0.3); }
    button.secondary { background: var(--input-bg); color: var(--text-main); border: 1px solid var(--border); }
    button.secondary:hover { background: var(--border); }

    /* MODAL STARTUP */
    #startup-modal {
      position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
      background: rgba(2, 6, 23, 0.95); z-index: 9999;
      display: flex; justify-content: center; align-items: center;
    }
    .modal-box {
      background: var(--bg-panel); padding: 40px; border-radius: 16px;
      border: 1px solid var(--border); max-width: 450px; text-align: center;
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.6);
    }
    .modal-box h2 { color: var(--accent); margin-top: 0; }
    .modal-box p { color: var(--text-dim); font-size: 14px; line-height: 1.6; margin-bottom: 30px; }

    /* Quality Selector */
    .quality-selector { display: flex; background: var(--input-bg); padding: 4px; border-radius: 6px; margin-top: 5px; border: 1px solid var(--border); }
    .q-btn { flex: 1; text-align: center; font-size: 11px; padding: 6px; cursor: pointer; border-radius: 4px; color: var(--text-dim); transition: 0.2s; }
    .q-btn.active { background: var(--accent); color: #0f172a; font-weight: bold; }
    .q-btn:hover:not(.active) { background: rgba(255,255,255,0.05); }

  </style>
</head>

<body>

  <div id="startup-modal">
    <div class="modal-box">
      <h2>Simulateur LBM Joukowsky</h2>
      <p>
        Simulation a√©rodynamique num√©rique (CFD) utilisant la m√©thode Lattice Boltzmann (D2Q9).<br><br>
        <span style="font-size:12px; color:#64748b;">Calcul√© en JavaScript sur le processeur.</span>
      </p>
      <button id="btn-start-modal" class="primary" style="width:100%">D√©marrer la Simulation</button>
    </div>
  </div>

  <header>
    <div style="display:flex; align-items:center; gap:10px;">
      <h1>Virtual Wind Tunnel</h1>
      <span class="badge">PRO</span>
    </div>
    <span class="badge" style="color: #94a3b8; border-color:#334155;">JS/Canvas Solver</span>
  </header>

  <main class="layout">
    <section id="sim-container">
      <canvas id="sim-canvas" width="600" height="240"></canvas>

      <div class="canvas-controls">
        <select id="viz-mode">
          <option value="curl">Vorticit√© (Tourbillons)</option>
          <option value="velocity">Magnitude Vitesse</option>
          <option value="pressure">Champ de Pression</option>
          <option value="streamlines">Lignes de Courant</option>
          <option value="vectors">Vecteurs</option>
        </select>
        <button id="btn-screenshot" class="secondary" style="padding:6px 12px;">üì∑</button>
      </div>
      
      <div class="overlay legend-panel">
        <span class="legend-val" id="val-max">1.0</span>
        <div class="colorbar"></div>
        <span class="legend-val" id="val-min">0.0</span>
      </div>

      <div class="overlay stats-panel">
        <span>FPS: <span id="fps-counter">0</span></span>
        <span>Steps: <span id="steps-count">0</span></span>
        <span style="color:var(--accent)">Grid: <span id="grid-display">--</span></span>
      </div>
    </section>

    <aside id="controls">
      <div class="scroll-area">

        <div class="section">
          <h3>Conditions d'√âcoulement</h3>
          
          <div class="control">
            <div class="label-row"><label>Vitesse (Mach)</label><span class="val-display" id="disp-mach">0.10</span></div>
            <input type="range" id="in-mach" min="0.02" max="0.18" step="0.01" value="0.10">
          </div>

          <div class="control">
            <div class="label-row"><label>Viscosit√© (Tau)</label><span class="val-display" id="disp-tau">0.80</span></div>
            <input type="range" id="in-tau" min="0.52" max="1.50" step="0.01" value="0.80">
          </div>

          <div class="results-grid">
            <div class="res-item"><span class="res-lbl">Reynolds</span><span class="res-val" id="res-re">~2000</span></div>
            <div class="res-item"><span class="res-lbl">Viscosit√©</span><span class="res-val" id="res-nu">0.10</span></div>
          </div>
        </div>

        <div class="section">
          <h3>Profil Joukowsky</h3>

          <div class="control">
            <div class="label-row"><label>Angle d'Attaque (AoA)</label><span class="val-display" id="disp-aoa">5¬∞</span></div>
            <input type="range" id="in-aoa" min="-10" max="25" step="1" value="5">
          </div>

          <div class="control">
            <div class="label-row"><label>√âpaisseur (t/c)</label><span class="val-display" id="disp-thick">0.12</span></div>
            <input type="range" id="in-thick" min="0.06" max="0.20" step="0.01" value="0.12">
          </div>

          <div class="control">
            <div class="label-row"><label>Cambrure</label><span class="val-display" id="disp-camber">0.08</span></div>
            <input type="range" id="in-camber" min="0.00" max="0.20" step="0.01" value="0.08">
          </div>
        </div>

        <div class="section">
          <h3>Qualit√© Simulation</h3>
          <div class="quality-selector">
            <div class="q-btn" data-res="low">Basse (Rapide)</div>
            <div class="q-btn active" data-res="medium">Moyenne</div>
            <div class="q-btn" data-res="high">Haute (Lente)</div>
          </div>
          
          <div class="control" style="margin-top:15px;">
            <div class="label-row"><label>It√©rations / Frame</label><span class="val-display" id="disp-iter">2</span></div>
            <input type="range" id="in-iter" min="1" max="10" step="1" value="2">
          </div>
        </div>

        <div class="section">
          <h3>Coefficients A√©rodynamiques</h3>
          <div class="results-grid" style="grid-template-columns: 1fr 1fr 1fr;">
            <div class="res-item"><span class="res-lbl">CL (Portance)</span><span class="res-val" id="res-cl" style="color:var(--accent)">0.00</span></div>
            <div class="res-item"><span class="res-lbl">CD (Tra√Æn√©e)</span><span class="res-val" id="res-cd">0.00</span></div>
            <div class="res-item"><span class="res-lbl">L/D</span><span class="res-val" id="res-ld">0.0</span></div>
          </div>
          <p class="info-text">Calcul bas√© sur la th√©orie du profil mince (Thin Airfoil Theory).</p>
        </div>

      </div>

      <div class="footer-actions">
        <button id="btn-reset" class="secondary">R√©initialiser</button>
        <button id="btn-pause" class="primary">Pause</button>
      </div>
    </aside>
  </main>

<script>
  /**
   * =============================================================
   * LBM JOUKOWSKY SOLVER - LOGIQUE COMPLETE & REPAREE
   * =============================================================
   */

  // === CONFIG GLOBALE ===
  const canvas = document.getElementById("sim-canvas");
  const ctx = canvas.getContext("2d", { willReadFrequently: true }); // Optimisation lecture

  // Dimensions (Mises √† jour par updateGridSize)
  let Nx = 400;
  let Ny = 160;
  let size = Nx * Ny;

  // LBM D2Q9 Constants
  const Q = 9;
  const w = [4/9, 1/9, 1/9, 1/9, 1/9, 1/36, 1/36, 1/36, 1/36];
  const cx = [0, 1, 0, -1, 0, 1, -1, -1, 1];
  const cy = [0, 0, 1, 0, -1, 1, 1, -1, -1];
  const opp = [0, 3, 4, 1, 2, 7, 8, 5, 6]; // Indices oppos√©s
  const cs2 = 1/3; // Vitesse son^2

  // M√©moire
  let f, fTmp, rho, ux, uy, mask, vort, imgData, pixels;
  let airfoilPoly = [];

  // Etat
  let running = false;
  let steps = 0;
  let lastTime = performance.now();
  let frames = 0;

  // Param√®tres modifiables
  let params = {
    mach: 0.10,
    tau: 0.80,
    aoa: 5,
    thick: 0.12,
    camber: 0.08,
    viz: 'velocity',
    contrast: 1.0,
    iter: 2,
    res: 'medium'
  };

  // Max Values pour visualisation
  let displayMax = 1.0;
  let displayMin = 0.0;
  const LIMITS = { velocity: 0.25, pressure: 0.5, vorticity: 5.0 };

  // === 1. GESTIONNAIRE D'√âV√âNEMENTS (SETUP UI EN PREMIER) ===
  
  // Bouton D√©marrage Modal
  document.getElementById('btn-start-modal').onclick = function() {
    document.getElementById('startup-modal').style.display = 'none';
    if(!running) {
      initLBM(); 
      running = true;
      loop();
    }
  };

  // Boutons Action
  document.getElementById('btn-pause').onclick = function() {
    running = !running;
    this.innerText = running ? "Pause" : "Reprendre";
    if(running) loop();
  };

  document.getElementById('btn-reset').onclick = function() {
    initLBM();
  };

  document.getElementById('btn-screenshot').onclick = function() {
    const a = document.createElement('a');
    a.download = 'cfd_screenshot.png';
    a.href = canvas.toDataURL();
    a.click();
  };

  // Inputs Sliders (Liaison directe)
  function bindInput(id, paramKey, dispId, needsGeoUpdate=false) {
    const el = document.getElementById(id);
    const disp = document.getElementById(dispId);
    el.oninput = function(e) {
      const v = parseFloat(e.target.value);
      params[paramKey] = v;
      if(disp) disp.innerText = v.toFixed(2) + (paramKey==='aoa'?'¬∞':'');
      
      if(needsGeoUpdate) {
        buildAirfoilMask(); 
        updateAero(); // MAJ Coeffs
      } else if (paramKey === 'mach' || paramKey === 'tau') {
        updateAero(); // MAJ Reynolds
      }
    };
  }

  bindInput('in-mach', 'mach', 'disp-mach');
  bindInput('in-tau', 'tau', 'disp-tau');
  bindInput('in-aoa', 'aoa', 'disp-aoa', true);
  bindInput('in-thick', 'thick', 'disp-thick', true);
  bindInput('in-camber', 'camber', 'disp-camber', true);
  
  // Iterations Slider
  document.getElementById('in-iter').oninput = function(e) {
    params.iter = parseInt(e.target.value);
    document.getElementById('disp-iter').innerText = params.iter;
  };

  // Selecteur Visu
  document.getElementById('viz-mode').onchange = function(e) {
    params.viz = e.target.value;
    displayMax = 0.1; // Reset echelle visuelle
  };

  // Boutons Qualit√©
  document.querySelectorAll('.q-btn').forEach(btn => {
    btn.onclick = function() {
      document.querySelectorAll('.q-btn').forEach(b => b.classList.remove('active'));
      this.classList.add('active');
      params.res = this.dataset.res;
      updateGridSize(); // Re-allouer
    }
  });

  // === 2. COEUR DE SIMULATION (LBM ENGINE) ===

  function allocateMemory() {
    f = new Float32Array(Q * size);
    fTmp = new Float32Array(Q * size);
    rho = new Float32Array(size);
    ux = new Float32Array(size);
    uy = new Float32Array(size);
    mask = new Uint8Array(size);
    vort = new Float32Array(size);
    imgData = ctx.createImageData(Nx, Ny);
    pixels = imgData.data;
  }

  function updateGridSize() {
    if(params.res === 'low') { Nx=300; Ny=120; }
    else if(params.res === 'high') { Nx=800; Ny=320; }
    else { Nx=600; Ny=240; } // medium

    canvas.width = Nx; canvas.height = Ny;
    size = Nx * Ny;
    document.getElementById('grid-display').innerText = `${Nx}x${Ny}`;
    
    allocateMemory();
    initLBM();
  }

  // G√©om√©trie pr√©cise (Celle que tu voulais)
  function buildAirfoilMask() {
    mask.fill(0);
    // Murs
    for(let x=0; x<Nx; x++) { mask[x]=1; mask[x+(Ny-1)*Nx]=1; }

    // Params Joukowsky
    const angle = params.aoa * Math.PI / 180;
    const cosA = Math.cos(angle), sinA = Math.sin(angle);
    const Npts = 500;
    // Centrage
    const circleOff = 0.08 + params.camber * 0.35;
    let radius = 1.0 - params.thick * 0.6;
    if (radius < 0.25) radius = 0.25;

    // G√©n√©ration Polygone
    const pts = [];
    for(let k=0; k<Npts; k++) {
      const t = 2 * Math.PI * k / Npts;
      const zx = circleOff + radius * Math.cos(t);
      const zy = radius * Math.sin(t);
      
      // Transform Z = Zeta + 1/Zeta
      const den = zx*zx + zy*zy;
      const x_raw = zx + zx/den;
      const y_raw = zy - zy/den;

      // Rotation
      const xr = x_raw * cosA - y_raw * sinA;
      const yr = x_raw * sinA + y_raw * cosA;
      pts.push({x: xr, y: yr});
    }

    // Mapping √©cran
    let minX=1e9, maxX=-1e9, minY=1e9, maxY=-1e9;
    for(let p of pts) {
       if(p.x < minX) minX=p.x; if(p.x > maxX) maxX=p.x;
       if(p.y < minY) minY=p.y; if(p.y > maxY) maxY=p.y;
    }
    const spanX = maxX - minX, spanY = maxY - minY;
    const scale = 0.45 * Math.min(Nx/spanX, Ny/spanY);
    const cx_scr = Nx * 0.3;
    const cy_scr = Ny * 0.5;

    airfoilPoly = pts.map(p => ({
      x: cx_scr + (p.x - (maxX+minX)*0.5) * scale,
      y: cy_scr - (p.y - (maxY+minY)*0.5) * scale
    }));

    // Rasterisation (Point in Polygon)
    for(let y=0; y<Ny; y++) {
      for(let x=0; x<Nx; x++) {
        if(mask[x+y*Nx]) continue;
        
        // Raycast
        let inside = false;
        const px = x+0.5, py = y+0.5;
        for(let i=0, j=airfoilPoly.length-1; i<airfoilPoly.length; j=i++) {
           const xi = airfoilPoly[i].x, yi = airfoilPoly[i].y;
           const xj = airfoilPoly[j].x, yj = airfoilPoly[j].y;
           const intersect = ((yi > py) !== (yj > py)) && (px < (xj-xi)*(py-yi)/(yj-yi+1e-9)+xi);
           if(intersect) inside = !inside;
        }
        if(inside) mask[x+y*Nx] = 1;
      }
    }
  }

  function initLBM() {
    buildAirfoilMask();
    const u0 = params.mach * Math.sqrt(cs2);
    
    for(let i=0; i<size; i++) {
      rho[i] = 1.0;
      ux[i] = mask[i] ? 0 : u0;
      uy[i] = 0;
      
      const u2 = ux[i]*ux[i] + uy[i]*uy[i];
      for(let k=0; k<Q; k++) {
        const cu = 3*(cx[k]*ux[i] + cy[k]*uy[i]);
        f[k*size+i] = w[k]*rho[i]*(1 + cu + 0.5*cu*cu - 1.5*u2);
      }
    }
    steps = 0;
    updateAero();
  }

  // --- 3. STEP PHYSIQUE ---
  function lbmStep() {
    const uIn = params.mach * Math.sqrt(cs2);

    // 1. Macros & Collision
    for(let i=0; i<size; i++) {
      if(mask[i]) continue; // Sauter murs

      // Moments
      let r=0, u=0, v=0;
      for(let k=0; k<Q; k++) {
        const val = f[k*size+i];
        r += val;
        u += val*cx[k];
        v += val*cy[k];
      }
      
      // Inlet Gauche
      if(i % Nx === 0) { r=1.0; u=uIn; v=0; }
      // Outlet Droite (Extrapol simple)
      if((i+1) % Nx === 0) { 
         const left = i-1; 
         u = ux[left]; v = uy[left]; r = rho[left];
      }

      rho[i] = r;
      if(r>0) { ux[i]=u/r; uy[i]=v/r; }

      // Equilibre + Relax
      const u2 = ux[i]*ux[i] + uy[i]*uy[i];
      for(let k=0; k<Q; k++) {
        const cu = 3*(cx[k]*ux[i] + cy[k]*uy[i]);
        const feq = w[k]*r*(1 + cu + 0.5*cu*cu - 1.5*u2);
        fTmp[k*size+i] = f[k*size+i] - (f[k*size+i] - feq)/params.tau;
      }
    }

    // 2. Streaming + BounceBack
    for(let y=0; y<Ny; y++) {
      for(let x=0; x<Nx; x++) {
        const i = x + y*Nx;
        
        for(let k=0; k<Q; k++) {
           const nx = x + cx[k];
           const ny = y + cy[k];
           
           if(nx>=0 && nx<Nx && ny>=0 && ny<Ny) {
              const ni = nx + ny*Nx;
              if(mask[ni]) {
                // Rebond sur obstacle
                f[opp[k]*size + i] = fTmp[k*size + i];
              } else {
                // Propagation
                f[k*size + ni] = fTmp[k*size + i];
              }
           }
        }
      }
    }

    // 3. Calcul Vorticit√© (si besoin affichage)
    if(params.viz === 'vorticity' || params.viz === 'curl') {
       for(let y=1; y<Ny-1; y++) {
         for(let x=1; x<Nx-1; x++) {
           const i = x+y*Nx;
           if(!mask[i]) {
             // Curl 2D = dUy/dx - dUx/dy
             const duy_dx = (uy[i+1] - uy[i-1])*0.5;
             const dux_dy = (ux[i+Nx] - ux[i-Nx])*0.5;
             vort[i] = duy_dx - dux_dy;
           }
         }
       }
    }
    steps++;
  }

  // --- 4. RENDU & COULEURS ---
  
  function getColorMap(val) {
    // Palette "Turbo" simplifi√©e (Bleu -> Cyan -> Vert -> Jaune -> Rouge)
    val = Math.max(0, Math.min(1, val));
    const r = Math.min(1, Math.max(0, 3*val - 1.5)); 
    const g = Math.min(1, Math.max(0, 2 - 3*Math.abs(val - 0.6))); 
    const b = Math.min(1, Math.max(0, 2 - 3*val));
    return [r*255, g*255, b*255];
  }

  function getDivergingColor(val) {
    // Bleu - Noir - Rouge
    val = Math.max(-1, Math.min(1, val));
    let r=0, g=0, b=0;
    if(val > 0) { r=255*val; g=100*val; } // Rougeatre
    else { b=255*Math.abs(val); g=100*Math.abs(val); } // Bleuatre
    // Fond l√©g√®rement √©clair√©
    r+=15; g+=20; b+=30;
    return [r, g, b];
  }

  function render() {
    // Auto-scale liss√©
    let localMax = 0;
    
    // Scan pour trouver max (optionnel pour perf, on peut utiliser constante)
    if(params.viz === 'velocity') localMax = params.mach * 2.0;
    if(params.viz === 'vorticity') localMax = 0.15;
    if(params.viz === 'pressure') localMax = 0.05;

    // Smoothing affichage
    displayMax = displayMax * 0.95 + localMax * 0.05;
    const scale = 1.0 / (displayMax + 1e-6);

    document.getElementById('val-max').innerText = displayMax.toFixed(3);
    document.getElementById('val-min').innerText = "0.0";

    // Dessin Pixels
    for(let i=0; i<size; i++) {
      const p = i*4;
      if(mask[i]) {
        // Obstacle
        pixels[p]=60; pixels[p+1]=65; pixels[p+2]=70; pixels[p+3]=255;
      } else {
        let col = [0,0,0];
        
        if(params.viz === 'velocity' || params.viz === 'streamlines' || params.viz === 'vectors') {
          const speed = Math.sqrt(ux[i]**2 + uy[i]**2);
          col = getColorMap(speed * scale);
        } else if(params.viz === 'pressure') {
          const pres = (rho[i]-1.0) * 3.0; // Gain pression
          col = getDivergingColor(pres * scale * 10);
        } else { // Vorticity
          col = getDivergingColor(vort[i] * scale);
        }

        pixels[p]=col[0]; pixels[p+1]=col[1]; pixels[p+2]=col[2]; pixels[p+3]=255;
      }
    }
    ctx.putImageData(imgData, 0, 0);

    // Dessin Streamlines (Surcouche)
    if(params.viz === 'streamlines') {
      ctx.strokeStyle = "rgba(255,255,255,0.4)";
      ctx.lineWidth = 1;
      const stride = 15;
      ctx.beginPath();
      for(let y=stride; y<Ny; y+=stride) {
        for(let x=stride; x<Nx; x+=stride) {
           if(mask[x+y*Nx]) continue;
           let cx=x, cy=y;
           ctx.moveTo(cx, cy);
           // Trace ligne
           for(let k=0; k<10; k++) {
              const idx = (cx|0) + (cy|0)*Nx;
              if(mask[idx]) break;
              const u = ux[idx], v = uy[idx];
              const m = Math.sqrt(u*u+v*v);
              if(m<1e-4) break;
              cx += (u/m)*3; cy += (v/m)*3;
              if(cx<0||cx>=Nx||cy<0||cy>=Ny) break;
              ctx.lineTo(cx, cy);
           }
        }
      }
      ctx.stroke();
    }
    
    // Dessin Vecteurs
    if(params.viz === 'vectors') {
       ctx.strokeStyle = "rgba(255,255,255,0.6)";
       ctx.beginPath();
       const step = 20;
       for(let y=step/2; y<Ny; y+=step) {
         for(let x=step/2; x<Nx; x+=step) {
            const i = (x|0) + (y|0)*Nx;
            if(mask[i]) continue;
            const u = ux[i], v = uy[i];
            const m = Math.sqrt(u*u+v*v);
            if(m > 0.01) {
               const scaleVec = 30;
               ctx.moveTo(x, y);
               ctx.lineTo(x + u*scaleVec, y + v*scaleVec);
               // Petite tete
               ctx.rect(x + u*scaleVec, y + v*scaleVec, 1, 1);
            }
         }
       }
       ctx.stroke();
    }
  }

  // --- 5. DATA UPDATES ---
  function updateAero() {
     // Calcul Theorique
     const rad = Math.PI/180;
     let cl = 2 * Math.PI * (params.aoa * rad);
     // Saturation CL (d√©crochage simple)
     if(cl > 1.5) cl = 1.5 + (cl-1.5)*0.1;
     
     const cd = 0.01 + (cl*cl) / (Math.PI * 6.0); // Polaire parabolique approx
     const ld = cl / cd;

     document.getElementById('res-cl').innerText = cl.toFixed(3);
     document.getElementById('res-cd').innerText = cd.toFixed(4);
     document.getElementById('res-ld').innerText = ld.toFixed(1);

     // Reynolds
     const u = params.mach * Math.sqrt(cs2);
     const L = Nx * 0.2; // Corde approx
     const nu = (params.tau - 0.5)/3;
     const Re = u * L / nu;
     document.getElementById('res-re').innerText = "~" + Math.round(Re);
     document.getElementById('res-nu').innerText = nu.toFixed(3);
  }

  // --- 6. LOOP ---
  function loop() {
    if(!running) return;

    // Multi-step pour vitesse
    for(let k=0; k<params.iter; k++) {
      lbmStep();
    }
    
    render();
    
    // Stats FPS
    const now = performance.now();
    if(now - lastTime > 1000) {
      const fps = frames;
      document.getElementById('fps-counter').innerText = fps;
      document.getElementById('steps-count').innerText = steps;
      frames = 0;
      lastTime = now;
    }
    frames++;

    requestAnimationFrame(loop);
  }

  // --- 7. INIT AU CHARGEMENT ---
  // Pr√©-allocation pour affichage propre avant start
  updateGridSize(); // Alloue et affiche grille vide
  updateAero();

</script>
</body>
</html>
