<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flow Simulator by Hamza Boudhair</title>
  <style>
    :root {
      --color-bg-primary: #0f172a;
      --color-surface: #1e293b;
      --color-text: #e2e8f0;
      --color-primary: #06b6d4;
      --color-accent: #10b981;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; user-select: none; }

    body {
      background: var(--color-bg-primary);
      color: var(--color-text);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      height: 100vh;
      overflow: hidden;
    }

    .container {
      display: flex;
      height: 100vh;
      gap: 20px;
      padding: 20px;
    }

    /* ZONE CANVAS */
    .canvas-wrapper {
      flex: 1;
      background: #000;
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid rgba(6, 182, 212, 0.2);
      box-shadow: 0 0 30px rgba(6, 182, 212, 0.1);
      position: relative;
    }

    canvas { width: 100%; height: 100%; display: block; }

    /* BARRE LAT√âRALE */
    .sidebar {
      width: 320px;
      background: var(--color-surface);
      border-radius: 12px;
      padding: 24px;
      border: 1px solid rgba(6, 182, 212, 0.1);
      overflow-y: auto;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      display: flex;
      flex-direction: column;
    }

    /* Scrollbar custom */
    .sidebar::-webkit-scrollbar { width: 6px; }
    .sidebar::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.05); }
    .sidebar::-webkit-scrollbar-thumb { background: var(--color-primary); border-radius: 3px; }

    h1 {
      font-size: 18px; margin-bottom: 24px; color: var(--color-primary);
      text-transform: uppercase; letter-spacing: 1px; font-weight: 800;
      border-bottom: 1px solid rgba(6, 182, 212, 0.2); padding-bottom: 15px;
    }

    h3 {
      font-size: 11px; text-transform: uppercase; letter-spacing: 1px;
      color: rgba(255, 255, 255, 0.5); margin-top: 20px; margin-bottom: 10px; font-weight: 600;
    }

    .control-group { margin-bottom: 16px; }

    .label-row {
      display: flex; justify-content: space-between; margin-bottom: 6px; font-size: 12px;
    }
    .label-row label { color: #cbd5e1; font-weight: 500; }
    .value { color: var(--color-primary); font-weight: 700; font-family: 'Monaco', monospace; }

    /* Sliders */
    input[type="range"] {
      width: 100%; height: 5px; border-radius: 3px;
      background: rgba(255, 255, 255, 0.1); outline: none; -webkit-appearance: none;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none; width: 16px; height: 16px; border-radius: 50%;
      background: var(--color-primary); cursor: pointer;
      border: 2px solid var(--color-bg-primary);
      box-shadow: 0 0 10px rgba(6, 182, 212, 0.5);
      transition: transform 0.1s;
    }
    input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.2); }

    /* Dropdown */
    select {
      width: 100%; padding: 8px; background: rgba(0,0,0,0.2);
      color: #fff; border: 1px solid rgba(255,255,255,0.1);
      border-radius: 6px; font-size: 12px; outline: none;
    }

    /* Boutons */
    .button-group { display: flex; gap: 8px; margin-top: 20px; }
    
    button {
      flex: 1; padding: 10px; background: var(--color-primary);
      color: #000; border: none; border-radius: 6px;
      font-weight: 700; font-size: 11px; text-transform: uppercase;
      cursor: pointer; transition: all 0.2s;
    }
    button:hover { filter: brightness(1.1); transform: translateY(-1px); }
    button:active { transform: translateY(0); }

    button.secondary {
      background: transparent; color: var(--color-primary);
      border: 1px solid var(--color-primary);
    }
    button.secondary:hover { background: rgba(6, 182, 212, 0.1); }

    .preset-buttons { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 6px; margin-top: 10px; }
    .preset-buttons button { padding: 6px; font-size: 10px; }

    /* Stats Panel */
    .stats {
      margin-top: 20px; padding: 12px;
      background: rgba(0, 0, 0, 0.2); border-radius: 8px;
      font-size: 11px; font-family: 'Monaco', monospace;
    }
    .stat-line { display: flex; justify-content: space-between; margin-bottom: 4px; color: #94a3b8; }
    .stat-value { color: #e2e8f0; }

    .hint {
      position: absolute; bottom: 20px; left: 20px;
      font-size: 12px; color: rgba(255, 255, 255, 0.4);
      pointer-events: none;
    }

    /* --- SIGNATURE HAMZA BOUDHAIR --- */
    .credits {
      margin-top: auto; /* Pousse en bas */
      padding-top: 20px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      text-align: center;
      font-size: 11px;
      color: #64748b;
      line-height: 1.6;
    }
    .credits span {
      color: var(--color-primary);
      font-weight: 700;
      font-size: 13px;
      letter-spacing: 0.5px;
    }
  </style>
</head>
<body>

<div class="container">
  <div class="canvas-wrapper">
    <canvas id="canvas"></canvas>
    <div class="hint">üñ±Ô∏è Drag airfoil to move | Space to pause</div>
  </div>

  <div class="sidebar">
    <h1>üåä CFD Studio</h1>

    <h3>Simulation Mode</h3>
    <div class="control-group">
      <select id="simType">
        <option value="vorticity">üåÄ Vorticity (Turbulence)</option>
        <option value="velocity">üí® Velocity Speed</option>
        <option value="pressure">‚ö° Pressure Field</option>
      </select>
    </div>

    <h3>Parameters</h3>
    <div class="control-group">
      <div class="label-row"><label>Wind Speed (Mach)</label><span class="value" id="machVal">0.20</span></div>
      <input type="range" id="machSlider" min="0.05" max="0.4" step="0.01" value="0.20">
    </div>
    <div class="control-group">
      <div class="label-row"><label>Viscosity</label><span class="value" id="viscVal">0.020</span></div>
      <input type="range" id="viscSlider" min="0.005" max="0.1" step="0.005" value="0.020">
    </div>
    <div class="control-group">
      <div class="label-row"><label>Angle of Attack</label><span class="value" id="aoaVal">12¬∞</span></div>
      <input type="range" id="aoaSlider" min="-45" max="45" step="1" value="12">
    </div>
    <div class="control-group">
      <div class="label-row"><label>Contrast</label><span class="value" id="contrastVal">2.0</span></div>
      <input type="range" id="contrastSlider" min="1.0" max="5.0" step="0.1" value="2.0">
    </div>

    <h3>Quick Presets</h3>
    <div class="preset-buttons">
      <button class="secondary" onclick="applyPreset('cruise')">Cruise</button>
      <button class="secondary" onclick="applyPreset('stall')">Stall</button>
      <button class="secondary" onclick="applyPreset('turb')">Turbulence</button>
    </div>

    <div class="button-group">
      <button onclick="resetSimulation()">Reset</button>
      <button class="secondary" id="pauseBtn" onclick="togglePause()">Pause</button>
    </div>

    <div class="stats">
      <div class="stat-line"><span>FPS:</span><span class="stat-value" id="fpsCounter">60</span></div>
      <div class="stat-line"><span>Resolution:</span><span class="stat-value">400x200</span></div>
      <div class="stat-line"><span>Method:</span><span class="stat-value">LBM D2Q9</span></div>
    </div>

    <div class="credits">
      Interactive Simulation<br>
      Created by <span>Hamza Boudhair</span>
    </div>
  </div>
</div>

<script>
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { alpha: false });

  // --- CONFIGURATION ---
  let Nx = 400, Ny = 200;
  const Q = 9;
  
  // --- ETAT ---
  let running = true;
  let simType = 'vorticity';
  let visc = 0.020;
  let u0 = 0.115; // Mach 0.2 √©quivalent
  let contrast = 2.0;
  let airfoilX = Nx * 0.25;
  let airfoilY = Ny * 0.5;
  let isDragging = false;

  // --- TABLEAUX MEMOIRE ---
  let f = new Float32Array(Nx * Ny * Q);
  let fNew = new Float32Array(Nx * Ny * Q);
  let rho = new Float32Array(Nx * Ny);
  let ux = new Float32Array(Nx * Ny);
  let uy = new Float32Array(Nx * Ny);
  let mask = new Uint8Array(Nx * Ny);
  let imgBuf = new ArrayBuffer(Nx * Ny * 4);
  let img32 = new Uint32Array(imgBuf);

  // LBM CONSTANTES
  const w = [4/9, 1/9, 1/9, 1/9, 1/9, 1/36, 1/36, 1/36, 1/36];
  const cx = [0, 1, 0, -1, 0, 1, -1, -1, 1];
  const cy = [0, 0, 1, 0, -1, 1, 1, -1, -1];
  const opp = [0, 3, 4, 1, 2, 7, 8, 5, 6];

  let airfoilPath = new Path2D();
  
  // FPS
  let frameCount = 0, lastFpsTime = Date.now();

  // --- INIT ---
  function init() {
    for (let i = 0; i < Nx * Ny; i++) {
      rho[i] = 1;
      ux[i] = mask[i] ? 0 : u0;
      uy[i] = 0;
      let u2 = ux[i] * ux[i] + uy[i] * uy[i];
      for (let k = 0; k < Q; k++) {
        let eu = cx[k] * ux[i] + cy[k] * uy[i];
        f[i * Q + k] = w[k] * rho[i] * (1 + 3 * eu + 4.5 * eu * eu - 1.5 * u2);
      }
    }
  }

  // --- GEOMETRIE (JOUKOWSKY) ---
  function buildGeo() {
    mask.fill(0);
    airfoilPath = new Path2D();
    const aoa = -parseFloat(document.getElementById('aoaSlider').value) * Math.PI / 180;
    const chord = Nx * 0.4;
    
    let th = 0.12;
    let cm = 0.1;
    let be = cm * 2;
    let ep = th * 0.8;
    let R = Math.sqrt((1 + ep) * (1 + ep) + be * be);
    let z0x = -ep, z0y = be;

    let points = [];
    const Np = 200;

    for (let i = 0; i <= Np; i++) {
      let t = 2 * Math.PI * i / Np;
      let zx = z0x + R * Math.cos(t);
      let zy = z0y + R * Math.sin(t);
      let den = zx * zx + zy * zy; if (den < 0.001) den = 0.001;
      let wx = zx * (1 + 1 / den);
      let wy = zy * (1 - 1 / den);
      let rx = (wx * Math.cos(aoa) - wy * Math.sin(aoa)) * (chord / 4) + airfoilX;
      let ry = (wx * Math.sin(aoa) + wy * Math.cos(aoa)) * (chord / 4) + airfoilY;
      points.push({ x: rx, y: ry });
    }

    // Remplissage Masque
    let minX = Nx, maxX = 0, minY = Ny, maxY = 0;
    points.forEach(p => {
      if (p.x < minX) minX = p.x; if (p.x > maxX) maxX = p.x;
      if (p.y < minY) minY = p.y; if (p.y > maxY) maxY = p.y;
    });
    minX = Math.max(0, Math.floor(minX)); maxX = Math.min(Nx, Math.ceil(maxX));
    minY = Math.max(0, Math.floor(minY)); maxY = Math.min(Ny, Math.ceil(maxY));

    for (let y = minY; y < maxY; y++) {
      for (let x = minX; x < maxX; x++) {
        let inside = false;
        for (let i = 0, j = Np - 1; i < Np; j = i++) {
          if (((points[i].y > y) != (points[j].y > y)) &&
            (x < (points[j].x - points[i].x) * (y - points[i].y) / (points[j].y - points[i].y) + points[i].x)) {
            inside = !inside;
          }
        }
        if (inside) mask[x + y * Nx] = 1;
      }
    }

    // Chemin Vectoriel
    airfoilPath.moveTo(points[0].x, points[0].y);
    for (let i = 1; i < points.length; i++) airfoilPath.lineTo(points[i].x, points[i].y);
    airfoilPath.closePath();
  }

  // --- PHYSIQUE ---
  function step() {
    let tau = 0.5 + 3 * visc;
    let om = 1.0 / tau;
    
    for (let i = 0; i < Nx * Ny; i++) {
      if (mask[i]) continue;
      let idx = i * Q;
      // Somme
      let r = f[idx] + f[idx+1] + f[idx+2] + f[idx+3] + f[idx+4] + f[idx+5] + f[idx+6] + f[idx+7] + f[idx+8];
      let u = (f[idx+1] - f[idx+3] + f[idx+5] - f[idx+6] - f[idx+7] + f[idx+8]) / r;
      let v = (f[idx+2] - f[idx+4] + f[idx+5] + f[idx+6] - f[idx+7] - f[idx+8]) / r;
      
      // Anti-Crash
      if (isNaN(u) || Math.abs(u) > 0.8) { init(); return; }
      
      rho[i] = r; ux[i] = u; uy[i] = v;
      let u2 = u * u + v * v;
      
      // Collision BGK
      for (let k = 0; k < Q; k++) {
        let eu = cx[k] * u + cy[k] * v;
        let feq = w[k] * r * (1 + 3 * eu + 4.5 * eu * eu - 1.5 * u2);
        f[idx + k] += om * (feq - f[idx + k]);
      }
    }

    // Streaming
    for (let y = 0; y < Ny; y++) {
      for (let x = 0; x < Nx; x++) {
        let i = x + y * Nx; if (mask[i]) continue;
        for (let k = 0; k < Q; k++) {
          let nx = x + cx[k], ny = y + cy[k];
          if (nx >= 0 && nx < Nx && ny >= 0 && ny < Ny) {
            let ni = nx + ny * Nx;
            if (mask[ni]) fNew[i * Q + opp[k]] = f[i * Q + k];
            else fNew[ni * Q + k] = f[i * Q + k];
          }
        }
      }
    }

    // Conditions Limites
    let u2in = u0 * u0;
    for (let y = 0; y < Ny; y++) { // Entr√©e
      let i = y * Nx; if (mask[i]) continue;
      for (let k = 0; k < Q; k++) {
        let eu = cx[k] * u0;
        fNew[i * Q + k] = w[k] * (1 + 3 * eu + 4.5 * eu * eu - 1.5 * u2in);
      }
    }
    for (let y = 0; y < Ny; y++) { // Sortie
      let i = (Nx - 1) + y * Nx;
      if (!mask[i]) { for (let k = 0; k < Q; k++) fNew[i * Q + k] = fNew[(i - 1) * Q + k]; }
    }

    let t = f; f = fNew; fNew = t;
  }

  // --- COULEURS ---
  function getColor(val) {
    val = Math.max(0, Math.min(1, val));
    let r, g, b;
    // Palette Cyan "Glow"
    r = Math.floor(val * 50);
    g = Math.floor(val * 200);
    b = Math.floor(val * 255);
    // Blanc en saturation
    if(val > 0.8) { r=255; g=255; b=255; }
    
    return (255 << 24) | (b << 16) | (g << 8) | r;
  }

  // --- DESSIN ---
  function draw() {
    for (let y = 1; y < Ny - 1; y++) {
      for (let x = 1; x < Nx - 1; x++) {
        let i = x + y * Nx;
        if (mask[i]) { img32[i] = 0xFF000000; continue; }
        
        let val = 0;
        if (simType === 'vorticity') {
          let curl = (ux[i + Nx] - ux[i - Nx]) - (uy[i + 1] - uy[i - 1]);
          let speed = Math.sqrt(ux[i]**2 + uy[i]**2);
          val = Math.abs(curl * 5.0) + (speed * 0.2);
        } else if (simType === 'velocity') {
          val = Math.sqrt(ux[i]**2 + uy[i]**2) * 3;
        } else {
          val = Math.abs(rho[i] - 1) * 15;
        }
        
        img32[i] = getColor(val * contrast);
      }
    }

    createImageBitmap(new ImageData(new Uint8ClampedArray(imgBuf), Nx, Ny)).then(spr => {
      let W = canvas.width = canvas.clientWidth;
      let H = canvas.height = canvas.clientHeight;
      
      ctx.imageSmoothingEnabled = true;
      ctx.fillStyle = 'black';
      ctx.fillRect(0, 0, W, H);
      ctx.drawImage(spr, 0, 0, W, H);
      
      // Dessin Aile Vectorielle
      let scX = W / Nx, scY = H / Ny;
      ctx.save();
      ctx.scale(scX, scY);
      ctx.fillStyle = '#0f172a';
      ctx.strokeStyle = '#06b6d4';
      ctx.lineWidth = 1.5 / scX;
      ctx.shadowColor = '#06b6d4';
      ctx.shadowBlur = 15;
      ctx.fill(airfoilPath);
      ctx.stroke(airfoilPath);
      ctx.restore();
    });
  }

  function loop() {
    if (running) { for (let k = 0; k < 8; k++) step(); }
    draw();
    frameCount++;
    if (Date.now() - lastFpsTime >= 1000) {
      document.getElementById('fpsCounter').textContent = frameCount;
      frameCount = 0; lastFpsTime = Date.now();
    }
    requestAnimationFrame(loop);
  }

  // --- INTERACTION UI ---
  function updateSliders() {
    u0 = parseFloat(document.getElementById('machSlider').value) * 0.577;
    visc = parseFloat(document.getElementById('viscSlider').value);
    contrast = parseFloat(document.getElementById('contrastSlider').value);
    simType = document.getElementById('simType').value;
    
    document.getElementById('machVal').textContent = document.getElementById('machSlider').value;
    document.getElementById('viscVal').textContent = document.getElementById('viscSlider').value;
    document.getElementById('aoaVal').textContent = document.getElementById('aoaSlider').value + "¬∞";
    document.getElementById('contrastVal').textContent = document.getElementById('contrastSlider').value;
    
    buildGeo();
    for (let i = 0; i < Nx * Ny; i++) if (mask[i]) { ux[i]=0; uy[i]=0; rho[i]=1; }
  }

  function applyPreset(name) {
    if(name=='cruise'){
      document.getElementById('machSlider').value = 0.25;
      document.getElementById('viscSlider').value = 0.02;
      document.getElementById('aoaSlider').value = 5;
    } else if(name=='stall') {
      document.getElementById('machSlider').value = 0.15;
      document.getElementById('viscSlider').value = 0.04;
      document.getElementById('aoaSlider').value = 25;
    } else { // turb
      document.getElementById('machSlider').value = 0.25;
      document.getElementById('viscSlider').value = 0.005;
      document.getElementById('aoaSlider').value = 15;
    }
    updateSliders();
  }

  function resetSimulation() { init(); }
  function togglePause() {
    running = !running;
    document.getElementById('pauseBtn').textContent = running ? "PAUSE" : "RESUME";
  }

  // Listeners
  ['machSlider','viscSlider','aoaSlider','contrastSlider'].forEach(id=>{
    document.getElementById(id).addEventListener('input', updateSliders);
  });
  document.getElementById('simType').addEventListener('change', updateSliders);

  // Dragging
  canvas.addEventListener('mousedown', e => {
    let rect = canvas.getBoundingClientRect();
    let mx = (e.clientX - rect.left) * (Nx / rect.width);
    let my = (e.clientY - rect.top) * (Ny / rect.height);
    if ((mx-airfoilX)**2 + (my-airfoilY)**2 < 900) isDragging = true;
  });
  window.addEventListener('mousemove', e => {
    if (isDragging) {
      let rect = canvas.getBoundingClientRect();
      airfoilX = Math.max(20, Math.min(Nx - 20, (e.clientX - rect.left) * (Nx / rect.width)));
      airfoilY = Math.max(20, Math.min(Ny - 20, (e.clientY - rect.top) * (Ny / rect.height)));
      buildGeo();
      for (let i = 0; i < Nx * Ny; i++) if (mask[i]) { ux[i]=0; uy[i]=0; rho[i]=1; }
    }
  });
  window.addEventListener('mouseup', () => isDragging = false);
  document.addEventListener('keydown', e => { if(e.code==='Space') togglePause(); });

  // Start
  buildGeo();
  init();
  loop();
</script>
</body>
</html>
