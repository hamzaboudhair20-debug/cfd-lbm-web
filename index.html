<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LBM Pro - High Fidelity</title>
  <style>
    /* UI Style identique à votre référence */
    * { box-sizing: border-box; user-select: none; font-family: 'Segoe UI', sans-serif; }
    body { margin: 0; background: #000; height: 100vh; overflow: hidden; }
    canvas { display: block; width: 100%; height: 100%; }

    #controls {
      position: absolute; top: 20px; right: 20px; width: 300px;
      padding: 20px;
      background: rgba(12, 20, 45, 0.85); /* Bleu nuit profond transparent */
      backdrop-filter: blur(12px);
      border: 1px solid rgba(100, 180, 255, 0.15);
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.6);
      color: white;
    }
    
    h2 { margin: 0 0 15px 0; font-size: 13px; color: #60a5fa; text-transform: uppercase; letter-spacing: 1px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 8px;}
    
    .group { margin-bottom: 15px; }
    .labels { display: flex; justify-content: space-between; font-size: 11px; color: #94a3b8; margin-bottom: 5px; font-weight: 600;}
    .val { color: #fff; }
    
    /* Slider Bleu Cyan Lumineux */
    input[type=range] { width: 100%; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; outline: none; -webkit-appearance: none; }
    input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 14px; height: 14px; background: #22d3ee; border-radius: 50%; box-shadow: 0 0 10px #22d3ee; cursor: pointer; border: 2px solid #0f172a; }

    .btns { display: flex; gap: 10px; margin-top: 20px; }
    button { flex: 1; padding: 8px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.1); color: #ddd; border-radius: 6px; cursor: pointer; font-size: 11px; font-weight: bold; transition: 0.2s; }
    button:hover { background: rgba(255,255,255,0.2); color: #fff; }

    .stats { margin-top: 15px; font-size: 10px; color: #64748b; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 10px; }
  </style>
</head>
<body>

<canvas id="c"></canvas>

<div id="controls">
  <h2>LBM Channel Flow (LES)</h2>
  
  <div class="group">
    <div class="labels"><span>Flow Speed</span><span id="v-mach" class="val">0.15</span></div>
    <input type="range" id="mach" min="0.05" max="0.3" step="0.01" value="0.15">
  </div>
  <div class="group">
    <div class="labels"><span>Viscosity</span><span id="v-visc" class="val">0.020</span></div>
    <input type="range" id="visc" min="0.01" max="0.08" step="0.001" value="0.020">
  </div>
  <div class="group">
    <div class="labels"><span>Angle</span><span id="v-aoa" class="val">8°</span></div>
    <input type="range" id="aoa" min="-20" max="25" step="1" value="8">
  </div>
  <div class="group">
    <div class="labels"><span>Thickness</span><span id="v-th" class="val">0.12</span></div>
    <input type="range" id="th" min="0.02" max="0.2" step="0.01" value="0.12">
  </div>
  <div class="group">
    <div class="labels"><span>Camber</span><span id="v-camb" class="val">0.10</span></div>
    <input type="range" id="camb" min="0" max="0.2" step="0.01" value="0.10">
  </div>
  <div class="group">
    <div class="labels"><span>Glow Intensity</span><span id="v-cont" class="val">1.2</span></div>
    <input type="range" id="cont" min="0.5" max="2.5" step="0.1" value="1.2">
  </div>

  <div class="btns">
    <button id="rst">Reset</button>
    <button id="pse">Pause</button>
  </div>
  <div class="stats" id="info">Running...</div>
</div>

<script>
// --- CONFIGURATION ---
const cvs = document.getElementById('c');
const ctx = cvs.getContext('2d', { alpha: false }); // Rapide

// Taille Simulation (Interne)
let Nx = 300; // Résolution physique (plus bas = plus stable + rapide)
let Ny = 150; 
const Q = 9;

// Params Physique
let visc = 0.02, u0 = 0.1;
let running = true;
let steps = 0;
let contrast = 1.2;

// Tableaux LBM
let f = new Float32Array(Nx*Ny*Q), fNew = new Float32Array(Nx*Ny*Q);
let rho = new Float32Array(Nx*Ny), ux = new Float32Array(Nx*Ny), uy = new Float32Array(Nx*Ny);
let mask = new Uint8Array(Nx*Ny);
// Buffer Image
let imgBuf = new ArrayBuffer(Nx*Ny*4);
let img32 = new Uint32Array(imgBuf);

// Géométrie Vectorielle (Pour le dessin lisse)
let airfoilPath = new Path2D();

// Constantes D2Q9
const w=[4/9,1/9,1/9,1/9,1/9,1/36,1/36,1/36,1/36];
const cx=[0,1,0,-1,0,1,-1,-1,1], cy=[0,0,1,0,-1,1,1,-1,-1];
const opp=[0,3,4,1,2,7,8,5,6];

// --- FONCTIONS ---

function init() {
  // Récup UI
  u0 = document.getElementById('mach').value * 0.577;
  visc = parseFloat(document.getElementById('visc').value);
  
  // Init Fluide
  for(let i=0; i<Nx*Ny; i++) {
    rho[i]=1; ux[i]=u0; uy[i]=0;
    if(mask[i]) { ux[i]=0; uy[i]=0; }
    let u2 = ux[i]**2 + uy[i]**2;
    for(let k=0; k<Q; k++) {
      let eu = cx[k]*ux[i] + cy[k]*uy[i];
      f[i*Q+k] = w[k]*rho[i]*(1+3*eu+4.5*eu*eu-1.5*u2);
    }
  }
  steps=0;
}

function buildGeo() {
  // Paramètres
  let aoa = -document.getElementById('aoa').value * Math.PI/180;
  let th = parseFloat(document.getElementById('th').value);
  let cm = parseFloat(document.getElementById('camb').value);
  
  mask.fill(0);
  airfoilPath = new Path2D(); // Reset chemin vectoriel

  // Joukowsky Transform
  let cX = Nx*0.35, cY = Ny*0.5, chord = Nx*0.45;
  let be = cm*2, ep = th*0.8;
  let R = Math.sqrt((1+ep)**2 + be**2);
  let z0x = -ep, z0y = be;
  
  let points = [];
  const Np = 200;
  
  // 1. Calcul des points du contour
  for(let i=0; i<=Np; i++) {
    let t = 2*Math.PI*i/Np;
    let zx = z0x + R*Math.cos(t), zy = z0y + R*Math.sin(t);
    let d = zx*zx + zy*zy;
    let wx = zx*(1+1/d), wy = zy*(1-1/d);
    // Rotation
    let rx = (wx*Math.cos(aoa) - wy*Math.sin(aoa)) * (chord/4) + cX;
    let ry = (wx*Math.sin(aoa) + wy*Math.cos(aoa)) * (chord/4) + cY;
    points.push({x:rx, y:ry});
  }

  // 2. Création du Masque (Physique pixelisée)
  // Algorithme polygone simple
  for(let y=0; y<Ny; y++) {
    for(let x=0; x<Nx; x++) {
      let ins = false;
      for(let i=0,j=Np-1; i<Np; j=i++) {
        if( ((points[i].y>y)!=(points[j].y>y)) && (x<(points[j].x-points[i].x)*(y-points[i].y)/(points[j].y-points[i].y)+points[i].x) ) ins=!ins;
      }
      if(ins) mask[x+y*Nx]=1;
    }
  }

  // 3. Création du Chemin Vectoriel (Dessin Lisse)
  // On utilise l'échelle du canvas d'affichage, pas celle de simulation
  airfoilPath.moveTo(points[0].x, points[0].y);
  for(let i=1; i<points.length; i++) airfoilPath.lineTo(points[i].x, points[i].y);
  airfoilPath.closePath();
}

function step() {
  let tau = 0.5 + 3*visc, om = 1/tau;
  
  // Collision
  for(let i=0; i<Nx*Ny; i++) {
    if(mask[i]) continue;
    let idx=i*Q;
    let r=0,u=0,v=0;
    for(let k=0; k<Q; k++) r+=f[idx+k];
    u=(f[idx+1]-f[idx+3]+f[idx+5]-f[idx+6]-f[idx+7]+f[idx+8])/r;
    v=(f[idx+2]-f[idx+4]+f[idx+5]+f[idx+6]-f[idx+7]-f[idx+8])/r;
    
    // Anti-crash simple
    if(isNaN(u)) { init(); return; }

    rho[i]=r; ux[i]=u; uy[i]=v;
    let u2=u*u+v*v;
    for(let k=0; k<Q; k++) {
      let eu=cx[k]*u+cy[k]*v;
      let feq=w[k]*r*(1+3*eu+4.5*eu*eu-1.5*u2);
      f[idx+k] += om*(feq-f[idx+k]);
    }
  }
  
  // Stream
  for(let y=0; y<Ny; y++) {
    for(let x=0; x<Nx; x++) {
      let i=x+y*Nx; if(mask[i]) continue;
      for(let k=0; k<Q; k++) {
        let nx=x+cx[k], ny=y+cy[k];
        if(nx>=0 && nx<Nx && ny>=0 && ny<Ny) {
          let ni=nx+ny*Nx;
          if(mask[ni]) fNew[i*Q+opp[k]] = f[i*Q+k]; // Rebond
          else fNew[ni*Q+k] = f[i*Q+k];
        }
      }
    }
  }
  
  // BC Inlet
  let u2in=u0**2;
  for(let y=0; y<Ny; y++) {
    let i=y*Nx; if(mask[i]) continue;
    for(let k=0; k<Q; k++) {
      let eu=cx[k]*u0;
      fNew[i*Q+k] = w[k]*(1+3*eu+4.5*eu*eu-1.5*u2in);
    }
  }
  // BC Outlet
  for(let y=0; y<Ny; y++) {
    let i=(Nx-1)+y*Nx; if(!mask[i]) {
      for(let k=0; k<Q; k++) fNew[i*Q+k]=fNew[(i-1)*Q+k];
    }
  }
  
  let t=f; f=fNew; fNew=t;
  steps++;
}

function draw() {
  // 1. Dessin du Fluide (Pixel Array)
  let maxV = u0 * (2.5/contrast);
  
  for(let i=0; i<Nx*Ny; i++) {
    if(mask[i]) { 
      img32[i] = 0xFF000000; // Transparent/Noir (sera couvert par le dessin vectoriel)
      continue; 
    }
    
    let v = Math.sqrt(ux[i]**2 + uy[i]**2);
    let t = v/maxV; if(t>1) t=1;
    
    // Palette "Deep Glow" (Bleu profond -> Cyan -> Blanc)
    // C'est le secret pour que ça ressemble à l'image de référence
    let r,g,b;
    
    // Fond: Bleu Nuit Profond (0, 10, 30)
    // Vitesse Moyenne: Bleu Royal Vibrant (30, 100, 255)
    // Haute Vitesse: Cyan Lumineux (100, 255, 255)
    
    if(t < 0.5) {
      let tt = t*2;
      r = 0 + 30*tt;
      g = 10 + 90*tt;
      b = 40 + 215*tt;
    } else {
      let tt = (t-0.5)*2;
      r = 30 + 225*tt;
      g = 100 + 155*tt;
      b = 255;
    }
    
    img32[i] = (255<<24) | (b<<16) | (g<<8) | r;
  }
  
  // Affichage simulation étirée
  // On utilise un canvas temporaire pour dessiner les pixels sans lissage
  // Puis on dessine l'aile avec lissage
  createImageBitmap(new ImageData(new Uint8ClampedArray(imgBuf), Nx, Ny)).then(spr => {
    // Etirement plein écran
    let W = cvs.width = cvs.clientWidth;
    let H = cvs.height = cvs.clientHeight;
    
    // Dessin fluide (lissé pour faire "Glow")
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.drawImage(spr, 0, 0, W, H);
    
    // 2. DESSIN VECTORIEL DE L'AILE (Anti-Aliasing Parfait)
    // On doit mettre à l'échelle le path
    let scX = W/Nx, scY = H/Ny;
    
    ctx.save();
    ctx.scale(scX, scY);
    ctx.lineWidth = 2.0/scX; // Bordure fine constante
    
    ctx.fillStyle = '#e2e8f0'; // Blanc cassé (Slate-200)
    ctx.strokeStyle = '#0f172a'; // Contour sombre
    ctx.shadowColor = 'rgba(0,0,0,0.5)'; // Ombre portée pour détacher du fond
    ctx.shadowBlur = 10;
    
    ctx.fill(airfoilPath);
    ctx.stroke(airfoilPath);
    
    ctx.restore();
  });
  
  document.getElementById('info').innerText = "Steps: " + steps + " | Mesh: " + Nx + "x" + Ny;
}

function loop() {
  if(running) {
    for(let k=0; k<8; k++) step(); // 8 itérations par frame
    draw();
  }
  requestAnimationFrame(loop);
}

// Listeners
function updateVal(id, unit="") {
  let el = document.getElementById(id);
  document.getElementById("v-"+id).innerText = el.value + unit;
  return el;
}

['mach','visc','aoa','th','camb','cont'].forEach(id => {
  document.getElementById(id).addEventListener('input', e => {
    updateVal(id, id=='aoa'?'°':'');
    if(id=='mach') u0 = e.target.value*0.577;
    else if(id=='visc') visc = parseFloat(e.target.value);
    else if(id=='cont') contrast = parseFloat(e.target.value);
    else { buildGeo(); init(); } // Changement géométrie
  });
});

document.getElementById('rst').onclick = init;
document.getElementById('pse').onclick = () => running = !running;

// Start
buildGeo();
init();
loop();

</script>
</body>
</html>
