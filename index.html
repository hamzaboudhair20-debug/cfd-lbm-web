<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>LBM Ultimate - Interactive</title>
  <style>
    * { box-sizing: border-box; user-select: none; touch-action: none; font-family: 'Segoe UI', sans-serif; }
    body { margin: 0; background: #000205; height: 100vh; overflow: hidden; cursor: crosshair; }
    canvas { display: block; width: 100%; height: 100%; }

    /* UI Style Glassmorphism */
    #controls {
      position: absolute; top: 20px; right: 20px; width: 280px;
      padding: 20px;
      background: rgba(10, 18, 35, 0.7);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid rgba(100, 180, 255, 0.1);
      border-radius: 16px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
      color: white;
      transition: opacity 0.3s;
    }
    #controls:hover { opacity: 1; }
    
    h2 { margin: 0 0 15px 0; font-size: 12px; color: #38bdf8; text-transform: uppercase; letter-spacing: 2px; font-weight: 800; }
    
    .group { margin-bottom: 12px; }
    .labels { display: flex; justify-content: space-between; font-size: 10px; color: #94a3b8; margin-bottom: 4px; font-weight: 600; text-transform: uppercase;}
    .val { color: #e0f2fe; }
    
    input[type=range] { 
      width: 100%; height: 4px; background: rgba(255,255,255,0.1); 
      border-radius: 2px; outline: none; -webkit-appearance: none; 
    }
    input[type=range]::-webkit-slider-thumb { 
      -webkit-appearance: none; width: 12px; height: 12px; 
      background: #38bdf8; border-radius: 50%; 
      box-shadow: 0 0 10px #38bdf8; cursor: pointer; 
      border: 2px solid #0f172a; 
      transition: transform 0.1s;
    }
    input[type=range]::-webkit-slider-thumb:hover { transform: scale(1.3); }

    .btns { display: flex; gap: 8px; margin-top: 20px; }
    button { 
      flex: 1; padding: 10px; background: rgba(56, 189, 248, 0.1); 
      border: 1px solid rgba(56, 189, 248, 0.2); color: #38bdf8; 
      border-radius: 6px; cursor: pointer; font-size: 10px; font-weight: bold; text-transform: uppercase;
      transition: 0.2s; 
    }
    button:hover { background: rgba(56, 189, 248, 0.3); color: #fff; box-shadow: 0 0 15px rgba(56, 189, 248, 0.4); }

    .hint { position: absolute; bottom: 20px; left: 20px; color: rgba(255,255,255,0.3); font-size: 12px; pointer-events: none; }
  </style>
</head>
<body>

<canvas id="c"></canvas>
<div class="hint">üñ±Ô∏è Drag to move airfoil</div>

<div id="controls">
  <h2>Aerodynamics Lab</h2>
  
  <div class="group">
    <div class="labels"><span>Wind Speed</span><span id="v-mach" class="val">0.15</span></div>
    <input type="range" id="mach" min="0.00" max="0.4" step="0.01" value="0.15">
  </div>
  <div class="group">
    <div class="labels"><span>Viscosity</span><span id="v-visc" class="val">0.020</span></div>
    <input type="range" id="visc" min="0.01" max="0.15" step="0.001" value="0.020">
  </div>
  <div class="group">
    <div class="labels"><span>Angle (AoA)</span><span id="v-aoa" class="val">10¬∞</span></div>
    <input type="range" id="aoa" min="-180" max="180" step="1" value="10">
  </div>
  <div class="group">
    <div class="labels"><span>Camber</span><span id="v-camb" class="val">0.12</span></div>
    <input type="range" id="camb" min="0" max="0.3" step="0.01" value="0.12">
  </div>
  <div class="group">
    <div class="labels"><span>Glow</span><span id="v-cont" class="val">1.4</span></div>
    <input type="range" id="cont" min="0.5" max="3.0" step="0.1" value="1.4">
  </div>

  <div class="btns">
    <button id="rst">Reset</button>
    <button id="pse">Pause</button>
  </div>
</div>

<script>
// --- 1. SETUP ---
const cvs = document.getElementById('c');
const ctx = cvs.getContext('2d', { alpha: false });

// R√©solution interne (Compromis Qualit√©/Vitesse)
let Nx = 300; 
let Ny = 150; 
const Q = 9;

// √âtat Physique
let visc = 0.02;
let u0 = 0.1; // Vitesse entr√©e
let running = true;
let steps = 0;
let contrast = 1.4;

// Position Aile (Interactive)
let airfoilX = Nx * 0.3;
let airfoilY = Ny * 0.5;
let isDragging = false;

// M√©moire (TypedArrays pour performance)
let f = new Float32Array(Nx*Ny*Q);
let fNew = new Float32Array(Nx*Ny*Q);
let rho = new Float32Array(Nx*Ny);
let ux = new Float32Array(Nx*Ny);
let uy = new Float32Array(Nx*Ny);
let mask = new Uint8Array(Nx*Ny); // 1=Solide, 0=Fluide
let imgBuf = new ArrayBuffer(Nx*Ny*4);
let img32 = new Uint32Array(imgBuf);

// LBM Constantes
const w=[4/9,1/9,1/9,1/9,1/9,1/36,1/36,1/36,1/36];
const cx=[0,1,0,-1,0,1,-1,-1,1], cy=[0,0,1,0,-1,1,1,-1,-1];
const opp=[0,3,4,1,2,7,8,5,6];

// Chemin vectoriel pour le dessin lisse
let airfoilPath = new Path2D();

// --- 2. INITIALISATION ---
function init() {
  // Initialise le fluide uniforme
  for(let i=0; i<Nx*Ny; i++) {
    rho[i] = 1; 
    ux[i] = mask[i] ? 0 : u0; 
    uy[i] = 0;
    
    // Equilibre initial
    let u2 = ux[i]**2 + uy[i]**2;
    for(let k=0; k<Q; k++) {
      let eu = cx[k]*ux[i] + cy[k]*uy[i];
      f[i*Q+k] = w[k] * rho[i] * (1 + 3*eu + 4.5*eu*eu - 1.5*u2);
    }
  }
  steps = 0;
}

// --- 3. G√âOM√âTRIE JOUKOWSKY (AVEC POSITION) ---
function buildGeo() {
  mask.fill(0);
  airfoilPath = new Path2D();

  const aoa = -parseFloat(document.getElementById('aoa').value) * Math.PI / 180;
  const cm = parseFloat(document.getElementById('camb').value);
  // Epaisseur fixe pour simplifier l'interaction
  const th = 0.12; 
  
  // Taille relative
  const chord = Nx * 0.4;
  
  // Param√®tres Cercle G√©n√©rateur
  let be = cm * 2; 
  let ep = th * 0.8;
  let R = Math.sqrt((1+ep)**2 + be**2);
  let z0x = -ep, z0y = be;
  
  let points = [];
  const Np = 150; // R√©solution contour

  // G√©n√©ration contour vectoriel
  for(let i=0; i<=Np; i++) {
    let t = 2 * Math.PI * i / Np;
    // Cercle
    let zx = z0x + R * Math.cos(t);
    let zy = z0y + R * Math.sin(t);
    // Joukowsky (z + 1/z)
    let den = zx*zx + zy*zy;
    if(den < 0.001) den = 0.001;
    let wx = zx * (1 + 1/den);
    let wy = zy * (1 - 1/den);
    // Rotation + Translation (airfoilX, airfoilY)
    let rx = (wx * Math.cos(aoa) - wy * Math.sin(aoa)) * (chord/4) + airfoilX;
    let ry = (wx * Math.sin(aoa) + wy * Math.cos(aoa)) * (chord/4) + airfoilY;
    points.push({x: rx, y: ry});
  }

  // 1. Cr√©ation du Masque (Physique)
  // On scanne la boite englobante pour gagner du temps
  let minX=Nx, maxX=0, minY=Ny, maxY=0;
  points.forEach(p => {
    if(p.x<minX) minX=p.x; if(p.x>maxX) maxX=p.x;
    if(p.y<minY) minY=p.y; if(p.y>maxY) maxY=p.y;
  });
  
  minX = Math.max(0, Math.floor(minX)); maxX = Math.min(Nx, Math.ceil(maxX));
  minY = Math.max(0, Math.floor(minY)); maxY = Math.min(Ny, Math.ceil(maxY));

  for(let y=minY; y<maxY; y++) {
    for(let x=minX; x<maxX; x++) {
      let inside = false;
      for(let i=0, j=Np-1; i<Np; j=i++) {
        if (((points[i].y>y) != (points[j].y>y)) &&
            (x < (points[j].x-points[i].x) * (y-points[i].y) / (points[j].y-points[i].y) + points[i].x)) {
          inside = !inside;
        }
      }
      if(inside) mask[x + y*Nx] = 1;
    }
  }

  // 2. Cr√©ation du Chemin (Visuel)
  airfoilPath.moveTo(points[0].x, points[0].y);
  for(let i=1; i<points.length; i++) airfoilPath.lineTo(points[i].x, points[i].y);
  airfoilPath.closePath();
}

// --- 4. MOTEUR PHYSIQUE (OPTIMIS√â) ---
function step() {
  let tau = 0.5 + 3 * visc;
  let om = 1.0 / tau;
  let stable = true;

  // A. Collision & Macroscopic
  for(let i=0; i<Nx*Ny; i++) {
    if(mask[i]) continue;
    
    let idx = i*Q;
    let r = 0, u = 0, v = 0;
    
    // Somme d√©roul√©e (plus rapide)
    r = f[idx]+f[idx+1]+f[idx+2]+f[idx+3]+f[idx+4]+f[idx+5]+f[idx+6]+f[idx+7]+f[idx+8];
    u = (f[idx+1]-f[idx+3]+f[idx+5]-f[idx+6]-f[idx+7]+f[idx+8]) / r;
    v = (f[idx+2]-f[idx+4]+f[idx+5]+f[idx+6]-f[idx+7]-f[idx+8]) / r;

    // STABILIT√â : Anti-Crash
    if(isNaN(u) || Math.abs(u) > 0.8) { stable = false; break; }

    rho[i] = r; ux[i] = u; uy[i] = v;
    
    let u2 = u*u + v*v;
    let c1 = 3, c2 = 4.5, c3 = 1.5;
    
    // Relaxation
    for(let k=0; k<Q; k++) {
      let eu = cx[k]*u + cy[k]*v;
      let feq = w[k] * r * (1 + c1*eu + c2*eu*eu - c3*u2);
      f[idx+k] += om * (feq - f[idx+k]);
    }
  }

  if(!stable) { init(); return; } // Reset auto si crash

  // B. Streaming
  for(let y=0; y<Ny; y++) {
    for(let x=0; x<Nx; x++) {
      let i = x + y*Nx;
      if(mask[i]) continue;
      
      for(let k=0; k<Q; k++) {
        let nx = x + cx[k], ny = y + cy[k];
        if(nx>=0 && nx<Nx && ny>=0 && ny<Ny) {
          let ni = nx + ny*Nx;
          if(mask[ni]) fNew[i*Q + opp[k]] = f[i*Q+k]; // Rebond
          else fNew[ni*Q + k] = f[i*Q+k];
        }
      }
    }
  }
  
  // C. Conditions Limites
  // Entr√©e (Inlet)
  let u2in = u0*u0;
  for(let y=0; y<Ny; y++) {
    let i = y*Nx;
    if(mask[i]) continue;
    for(let k=0; k<Q; k++) {
      let eu = cx[k]*u0;
      fNew[i*Q+k] = w[k] * (1 + 3*eu + 4.5*eu*eu - 1.5*u2in);
    }
  }
  
  // Sortie (Outlet) - Copie simple
  for(let y=0; y<Ny; y++) {
    let i = (Nx-1) + y*Nx;
    if(!mask[i]) {
      for(let k=0; k<Q; k++) fNew[i*Q+k] = fNew[(i-1)*Q+k];
    }
  }
  
  // Swap Pointers
  let t = f; f = fNew; fNew = t;
  steps++;
}

// --- 5. RENDU GRAPHIQUE "DEEP BLUE" ---
function draw() {
  let maxV = u0 * (2.5 / contrast);
  if(maxV < 0.01) maxV = 0.01;

  for(let i=0; i<Nx*Ny; i++) {
    if(mask[i]) { 
      img32[i] = 0xFF000000; // Transparent (masqu√© par le vecteur)
      continue; 
    }
    
    let v = Math.sqrt(ux[i]**2 + uy[i]**2);
    let t = v / maxV; 
    if(t > 1) t = 1;

    // Palette optimis√©e pour l'effet "Glow"
    let r, g, b;
    
    if(t < 0.4) {
      // Fond sombre -> Bleu moyen
      // 0x050A14 -> 0x1E40AF
      let tt = t / 0.4;
      r = 5 + 25 * tt;
      g = 10 + 54 * tt;
      b = 20 + 155 * tt;
    } else {
      // Bleu moyen -> Cyan -> Blanc
      let tt = (t - 0.4) / 0.6;
      r = 30 + 225 * tt;
      g = 64 + 191 * tt;
      b = 175 + 80 * tt;
    }
    
    // ABGR (Little Endian)
    img32[i] = (255 << 24) | (b << 16) | (g << 8) | r;
  }

  createImageBitmap(new ImageData(new Uint8ClampedArray(imgBuf), Nx, Ny)).then(spr => {
    // Etirer pour remplir l'√©cran
    let W = cvs.width = window.innerWidth;
    let H = cvs.height = window.innerHeight;
    
    // 1. Fond fluide
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = "high";
    ctx.drawImage(spr, 0, 0, W, H);
    
    // 2. Aile Vectorielle (Lisse)
    let scX = W / Nx;
    let scY = H / Ny;
    
    ctx.save();
    ctx.scale(scX, scY);
    
    // Ombre fluide autour de l'aile
    ctx.shadowColor = "rgba(0,0,0,0.8)";
    ctx.shadowBlur = 15;
    ctx.fillStyle = "#f1f5f9"; // Slate 100 (Blanc cass√©)
    ctx.fill(airfoilPath);
    
    ctx.restore();
  });
}

// --- 6. INTERACTION & BOUCLE ---
function loop() {
  if(running) {
    // Plus de steps = simulation plus rapide
    for(let k=0; k<8; k++) step();
    draw();
  }
  requestAnimationFrame(loop);
}

// Event Listeners
const sliders = ['mach','visc','aoa','camb','cont'];
sliders.forEach(id => {
  document.getElementById(id).addEventListener('input', e => {
    let val = e.target.value;
    document.getElementById('v-'+id).innerText = val + (id=='aoa'?'¬∞':'');
    
    if(id=='mach') u0 = val * 0.577;
    else if(id=='visc') visc = parseFloat(val);
    else if(id=='cont') contrast = parseFloat(val);
    else {
      buildGeo();
      // On clean le fluide √† l'int√©rieur de la nouvelle position
      for(let i=0; i<Nx*Ny; i++) if(mask[i]) { ux[i]=0; uy[i]=0; }
    }
  });
});

// Mouse Interaction
cvs.addEventListener('mousedown', e => {
  let rect = cvs.getBoundingClientRect();
  let mx = (e.clientX - rect.left) * (Nx / cvs.width);
  let my = (e.clientY - rect.top) * (Ny / cvs.height);
  // Check si on clique pr√®s de l'aile
  let dx = mx - airfoilX;
  let dy = my - airfoilY;
  if(dx*dx + dy*dy < 400) isDragging = true;
});

window.addEventListener('mousemove', e => {
  if(isDragging) {
    let rect = cvs.getBoundingClientRect();
    airfoilX = (e.clientX - rect.left) * (Nx / cvs.width);
    airfoilY = (e.clientY - rect.top) * (Ny / cvs.height);
    
    // Clamp pour ne pas sortir de l'√©cran
    airfoilX = Math.max(20, Math.min(Nx-20, airfoilX));
    airfoilY = Math.max(20, Math.min(Ny-20, airfoilY));
    
    buildGeo();
    // Nettoyage forc√© lors du d√©placement rapide pour √©viter les artefacts
    for(let i=0; i<Nx*Ny; i++) if(mask[i]) { ux[i]=0; uy[i]=0; rho[i]=1; }
  }
});

window.addEventListener('mouseup', () => isDragging = false);

document.getElementById('rst').onclick = init;
document.getElementById('pse').onclick = () => running = !running;

// Start
buildGeo();
init();
loop();

</script>
</body>
</html>
